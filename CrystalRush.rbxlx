<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">Shared</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">Config</string>
          <string name="Source"><![CDATA[local Config = {}

Config.GameName = "Crystal Rush"
Config.ZoneSpacing = 220
Config.ZoneY = 0
Config.ZoneSize = Vector3.new(140, 1, 140)
Config.BaseWalkSpeed = 14
Config.TeleportPadSize = Vector3.new(10, 1, 10)
Config.DepositPadSize = Vector3.new(14, 1, 14)
Config.DepositPosition = Vector3.new(0, 0.6, -20)
Config.OrbRespawnSeconds = 8
Config.MaxOrbsPerZone = 40
Config.InventoryTick = 0.25

Config.Zones = {
    {
        Name = "Starter Meadow",
        Description = "Collect shimmering shards and learn the basics.",
        UnlockCost = 0,
        OrbValue = 1,
        OrbColor = Color3.fromRGB(83, 203, 255),
        RareOrbValue = 8,
        RareChance = 0.08,
        OrbDensity = 26,
        Height = 0,
        TerrainMaterial = Enum.Material.Grass,
        TerrainColor = Color3.fromRGB(52, 157, 78),
        AccentColor = Color3.fromRGB(124, 255, 190),
        Props = { Trees = 6, Crystals = 4, Rocks = 4 }
    },
    {
        Name = "Crystal Caves",
        Description = "Hidden caverns with higher value finds.",
        UnlockCost = 750,
        OrbValue = 4,
        OrbColor = Color3.fromRGB(255, 89, 89),
        RareOrbValue = 30,
        RareChance = 0.1,
        OrbDensity = 28,
        Height = 8,
        TerrainMaterial = Enum.Material.Rock,
        TerrainColor = Color3.fromRGB(76, 86, 112),
        AccentColor = Color3.fromRGB(255, 153, 153),
        Props = { Crystals = 7, Pillars = 4 }
    },
    {
        Name = "Sunspire Desert",
        Description = "Hot sands with frequent energy bursts.",
        UnlockCost = 5200,
        OrbValue = 12,
        OrbColor = Color3.fromRGB(245, 205, 48),
        RareOrbValue = 70,
        RareChance = 0.12,
        OrbDensity = 30,
        Height = 4,
        TerrainMaterial = Enum.Material.Sand,
        TerrainColor = Color3.fromRGB(224, 186, 92),
        AccentColor = Color3.fromRGB(255, 230, 132),
        Props = { Crystals = 5, Pillars = 3, Flames = 2 }
    },
    {
        Name = "Storm Peaks",
        Description = "Lightning-charged air produces volatile shards.",
        UnlockCost = 18600,
        OrbValue = 28,
        OrbColor = Color3.fromRGB(124, 156, 255),
        RareOrbValue = 140,
        RareChance = 0.14,
        OrbDensity = 32,
        Height = 14,
        TerrainMaterial = Enum.Material.Basalt,
        TerrainColor = Color3.fromRGB(140, 147, 181),
        AccentColor = Color3.fromRGB(170, 198, 255),
        Props = { Crystals = 6, Pillars = 4, Storm = 3 }
    },
    {
        Name = "Luminous Lagoon",
        Description = "Bioluminescent waters with radiant energy.",
        UnlockCost = 52800,
        OrbValue = 60,
        OrbColor = Color3.fromRGB(16, 252, 194),
        RareOrbValue = 320,
        RareChance = 0.16,
        OrbDensity = 34,
        Height = 6,
        TerrainMaterial = Enum.Material.SmoothPlastic,
        TerrainColor = Color3.fromRGB(34, 112, 120),
        AccentColor = Color3.fromRGB(120, 255, 227),
        Props = { Crystals = 7, Water = true }
    },
    {
        Name = "Galactic Rift",
        Description = "Zero-gravity void with monumental shards.",
        UnlockCost = 158000,
        OrbValue = 140,
        OrbColor = Color3.fromRGB(206, 44, 255),
        RareOrbValue = 650,
        RareChance = 0.18,
        OrbDensity = 36,
        Height = 20,
        TerrainMaterial = Enum.Material.Neon,
        TerrainColor = Color3.fromRGB(51, 12, 77),
        AccentColor = Color3.fromRGB(216, 144, 255),
        Props = { Crystals = 9, Void = true }
    }
}

Config.Upgrades = {
    Capacity = {
        { Level = 1, Capacity = 20, Cost = 0 },
        { Level = 2, Capacity = 40, Cost = 150 },
        { Level = 3, Capacity = 75, Cost = 550 },
        { Level = 4, Capacity = 120, Cost = 1800 },
        { Level = 5, Capacity = 200, Cost = 5200 },
        { Level = 6, Capacity = 320, Cost = 14800 },
        { Level = 7, Capacity = 480, Cost = 42400 },
        { Level = 8, Capacity = 720, Cost = 120000 }
    },
    Speed = {
        { Level = 1, WalkSpeed = 14, Cost = 0 },
        { Level = 2, WalkSpeed = 16, Cost = 400 },
        { Level = 3, WalkSpeed = 18, Cost = 1600 },
        { Level = 4, WalkSpeed = 20, Cost = 5200 },
        { Level = 5, WalkSpeed = 22, Cost = 16800 },
        { Level = 6, WalkSpeed = 24, Cost = 56000 }
    },
    Converter = {
        { Level = 1, Multiplier = 1, Cost = 0 },
        { Level = 2, Multiplier = 1.3, Cost = 950 },
        { Level = 3, Multiplier = 1.6, Cost = 4400 },
        { Level = 4, Multiplier = 2.1, Cost = 15600 },
        { Level = 5, Multiplier = 2.8, Cost = 49800 },
        { Level = 6, Multiplier = 3.6, Cost = 162000 }
    }
}

Config.Rebirth = {
    BaseCost = 325000,
    CostMultiplier = 2.85,
    RewardMultiplier = 1.75,
    BonusEnergy = 3500
}

Config.Gamepasses = {
    VIP = {
        Name = "Crystal VIP",
        Benefit = "+10% Energy, VIP chat tag, exclusive shop",
        Price = 399,
        Id = 1476014436,
        DepositBonus = 0.1,
        ChatTag = "VIP",
        ChatColor = Color3.fromRGB(255, 226, 110)
    },
    HYPER_SPRINT = {
        Name = "Hyper Sprint",
        Benefit = "+50% movement speed toggle",
        Price = 149,
        Id = 1475776403,
        SpeedMultiplier = 1.5
    },
    INFINITE_STORAGE = {
        Name = "Infinite Storage",
        Benefit = "Never run out of backpack space",
        Price = 799,
        Id = 1476396573
    },
    LUCKY_AURA = {
        Name = "Lucky Aura",
        Benefit = "+20% luck for rare shards and pet rolls",
        Price = 249,
        Id = 1476674539,
        LuckBonus = 0.2
    },
    AUTO_COLLECTOR = {
        Name = "Auto Collector Drone",
        Benefit = "Automatically vacuum nearby shards",
        Price = 499,
        Id = 1475412430,
        Radius = 14,
        Interval = 1.5
    }
}

Config.VIPShop = {
    {
        Key = "VipBoost10",
        Name = "VIP Turbo Boost",
        Description = "x2 converter boost for 10 minutes",
        Cost = 4500,
        Multiplier = 2,
        Duration = 600
    },
    {
        Key = "VipBoost30",
        Name = "VIP Radiant Surge",
        Description = "x2.5 converter boost for 30 minutes",
        Cost = 12500,
        Multiplier = 2.5,
        Duration = 1800
    }
}

Config.DeveloperProducts = {
    EnergyPacks = {
        { Key = "SmallPack", Name = "Pocketful of Energy", Amount = 800, Price = 49, Id = 0 },
        { Key = "MediumPack", Name = "Crate of Energy", Amount = 2800, Price = 149, Id = 0 },
        { Key = "LargePack", Name = "Truck of Energy", Amount = 9200, Price = 399, Id = 0 },
        { Key = "UltraPack", Name = "Planetary Cache", Amount = 18500, Price = 799, Id = 0 }
    },
    Boosts = {
        { Key = "TwoXMultiplier10", Name = "10 min 2x Converter", Duration = 600, Multiplier = 2, Price = 99, Id = 0 },
        { Key = "TwoXMultiplier30", Name = "30 min 2x Converter", Duration = 1800, Multiplier = 2, Price = 249, Id = 0 }
    }
}

Config.DynamicEvents = {
    CRYSTAL_SURGE = {
        Name = "Crystal Surge",
        Description = "Crystals overflow with energy, doubling values and spawn rate.",
        Duration = 75,
        Color = Color3.fromRGB(111, 210, 255),
        Announcement = "Crystal Surge detected in %s!",
        ZoneModifier = {
            ValueMultiplier = 1.8,
            SpawnRateMultiplier = 2,
            TargetMultiplier = 1.6,
            RareChanceBonus = 0.18,
            ColorShift = Color3.fromRGB(255, 255, 255),
            Glow = true
        },
        Burst = {
            Count = 4,
            ValueMultiplier = 4,
            Size = Vector3.new(4.4, 4.4, 4.4),
            Interval = 14,
            Duration = 12,
            Sparkle = true,
            LightBrightness = 3
        }
    },
    PRISMATIC_BLOOM = {
        Name = "Prismatic Bloom",
        Description = "Giant prisms sprout across the zone with mega payouts.",
        Duration = 65,
        Color = Color3.fromRGB(255, 177, 231),
        Announcement = "%s is blooming with prismatic crystals!",
        ZoneModifier = {
            ValueMultiplier = 1.5,
            SpawnRateMultiplier = 1.6,
            TargetMultiplier = 1.4,
            RareChanceBonus = 0.22,
            ColorShift = Color3.fromRGB(255, 177, 231),
            Glow = true
        },
        Burst = {
            Count = 5,
            ValueMultiplier = 6,
            Size = Vector3.new(5.6, 5.6, 5.6),
            Interval = 18,
            Duration = 18,
            Sparkle = true,
            LightBrightness = 4
        }
    }
}

Config.DynamicEventCooldown = {
    Min = 55,
    Max = 85
}

Config.Combo = {
    Window = 4,
    BonusPerStreak = 0.04,
    MaxBonus = 0.4,
    NotifyThreshold = 5
}

Config.TutorialMessages = {
    "Welcome to Crystal Rush! Collect glowing shards on the island to fill your backpack.",
    "Step on the golden deposit pad at base to convert shards into Energy.",
    "Spend Energy on upgrades for capacity, speed, and converter multiplier for faster runs.",
    "Unlock new zones from the teleporter ring once you can afford them.",
    "Rebirth after maxing zones to permanently multiply your earnings!"
}

function Config.getZone(index)
    return Config.Zones[index]
end

function Config.getUpgradePath(upgradeType)
    return Config.Upgrades[upgradeType]
end

function Config.getNextUpgradeCost(upgradeType, currentLevel)
    local path = Config.Upgrades[upgradeType]
    if not path then
        return nil
    end

    local nextLevel = path[currentLevel + 1]
    return nextLevel and nextLevel.Cost or nil
end

function Config.getUpgradeStats(upgradeType, level)
    local path = Config.Upgrades[upgradeType]
    if not path then
        return nil
    end

    return path[level]
end

function Config.getZoneUnlockCost(index)
    local zone = Config.Zones[index]
    return zone and zone.UnlockCost or nil
end

function Config.getRebirthCost(rebirthCount)
    return math.floor(Config.Rebirth.BaseCost * (Config.Rebirth.CostMultiplier ^ rebirthCount))
end

function Config.getRebirthMultiplier(rebirths)
    return Config.Rebirth.RewardMultiplier ^ rebirths
end

return Config
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="3">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="4">
      <Properties>
        <string name="Name">GameInit</string>
        <token name="RunContext">0</token>
        <string name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Config = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Config"))

local modulesFolder = script.Parent:WaitForChild("Modules")

local RemotesModule = require(modulesFolder:WaitForChild("Remotes"))
local MapBuilder = require(modulesFolder:WaitForChild("MapBuilder"))
local SessionService = require(modulesFolder:WaitForChild("SessionService"))
local Monetization = require(modulesFolder:WaitForChild("Monetization"))
local UpgradeService = require(modulesFolder:WaitForChild("UpgradeService"))
local OrbManager = require(modulesFolder:WaitForChild("OrbManager"))
local ChatEffects = require(modulesFolder:WaitForChild("ChatEffects"))
local EventService = require(modulesFolder:WaitForChild("EventService"))

local remotes = RemotesModule.get()
local mapReferences = MapBuilder.build()

local vipItemsByKey = {}
for _, item in ipairs(Config.VIPShop) do
    vipItemsByKey[item.Key] = item
end

local function applyVipStatus(player)
    local isVip = Monetization.PlayerHasPass(player, "VIP")
    player:SetAttribute("IsVIP", isVip)

    if isVip then
        ChatEffects.ApplyVipFormatting(player, Config.Gamepasses.VIP.ChatTag, Config.Gamepasses.VIP.ChatColor)
    else
        ChatEffects.ClearVipFormatting(player)
    end
end

local function applyOwnedPassPerks(player)
    applyVipStatus(player)
    task.defer(UpgradeService.ApplyCharacterScaling, player)
    task.defer(OrbManager.UpdateAutoCollector, player)
end

local function createLeaderstats(player)
    local folder = Instance.new("Folder")
    folder.Name = "leaderstats"
    folder.Parent = player

    local energy = Instance.new("IntValue")
    energy.Name = "Energy"
    energy.Value = 0
    energy.Parent = folder

    local rebirths = Instance.new("IntValue")
    rebirths.Name = "Rebirths"
    rebirths.Value = 0
    rebirths.Parent = folder

    local zone = Instance.new("IntValue")
    zone.Name = "Zone"
    zone.Value = 1
    zone.Parent = folder
end

local function updateLeaderstats(player, summary)
    local leaderstats = player:FindFirstChild("leaderstats")
    if not leaderstats then
        return
    end

    local energy = leaderstats:FindFirstChild("Energy")
    if energy then
        energy.Value = summary.Energy
    end

    local rebirths = leaderstats:FindFirstChild("Rebirths")
    if rebirths then
        rebirths.Value = summary.Rebirths
    end

    local zone = leaderstats:FindFirstChild("Zone")
    if zone then
        zone.Value = summary.ZoneLevel
    end
end

local function teleportPlayer(player, targetPosition)
    local character = player.Character
    if not character then
        return
    end

    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then
        return
    end

    root.CFrame = CFrame.new(targetPosition + Vector3.new(0, 4, 0))
end

local function sendState(player)
    local summary = UpgradeService.GetStateSummary(player)
    if not summary then
        return
    end

    updateLeaderstats(player, summary)
    local eventSummary = EventService.GetEventSummary()
    if eventSummary then
        summary.ActiveEvent = eventSummary
    end
    remotes.StateUpdate:FireClient(player, summary)
end

UpgradeService.SetDependencies(remotes, Monetization)
Monetization.SetStateUpdateCallback(sendState)
Monetization.OnPassUnlocked(function(player, passKey)
    if passKey == "HYPER_SPRINT" then
        SessionService.SetSetting(player, "HyperSprint", true)
        task.defer(UpgradeService.ApplyCharacterScaling, player)
    elseif passKey == "AUTO_COLLECTOR" then
        SessionService.SetSetting(player, "AutoCollector", true)
        task.defer(OrbManager.UpdateAutoCollector, player)
    end

    task.defer(applyOwnedPassPerks, player)

    if passKey == "VIP" or passKey == "INFINITE_STORAGE" or passKey == "LUCKY_AURA" or passKey == "HYPER_SPRINT" or passKey == "AUTO_COLLECTOR" then
        task.defer(sendState, player)
    end
end)

Monetization.Init(remotes)
OrbManager.Init(mapReferences, remotes, Monetization, sendState)
EventService.Init(remotes, OrbManager, sendState)

local function handleDeposit(player)
    local session = SessionService.GetSession(player)
    if not session or session.Inventory <= 0 then
        return
    end

    local now = os.clock()
    local last = player:GetAttribute("LastDepositTime") or 0
    if now - last < 0.6 then
        return
    end
    player:SetAttribute("LastDepositTime", now)

    local multiplier = UpgradeService.GetConverterMultiplier(player)
    local comboInfo = SessionService.GetComboInfo(player)
    local comboMultiplier = comboInfo and comboInfo.Multiplier or 1
    local amount = math.floor(session.Inventory * multiplier * comboMultiplier)
    if amount <= 0 then
        SessionService.SetInventory(player, 0)
        SessionService.ResetCombo(player)
        return
    end

    if Monetization.PlayerHasPass(player, "VIP") then
        local bonus = Config.Gamepasses.VIP.DepositBonus or 0
        amount = math.floor(amount * (1 + bonus))
    end
    SessionService.SetInventory(player, 0)
    SessionService.ResetCombo(player)
    SessionService.AdjustEnergy(player, amount)
    local message = string.format("Deposited for %d Energy", amount)
    if comboInfo and comboInfo.Count and comboInfo.Count > 1 then
        message = message .. string.format(" (Combo x%d)", comboInfo.Count)
    end
    remotes.Notify:FireClient(player, message)
    sendState(player)
end

local function onDepositTouched(part)
    if not part or not part.Parent then
        return
    end

    local player = Players:GetPlayerFromCharacter(part.Parent)
    if not player then
        return
    end

    handleDeposit(player)
end

local function bindTeleporters()
    for index, pad in pairs(mapReferences.TeleporterPads) do
        pad.Touched:Connect(function(part)
            if not part or not part.Parent then
                return
            end

            local player = Players:GetPlayerFromCharacter(part.Parent)
            if not player then
                return
            end

            local session = SessionService.GetSession(player)
            if not session then
                return
            end

            if session.Data.ZoneLevel < index then
                local zoneConfig = Config.getZone(index)
                if zoneConfig then
                    remotes.Notify:FireClient(player, string.format("Unlock %s first!", zoneConfig.Name))
                end
                return
            end

            local zonePart = mapReferences.ZonePlatforms[index]
            if zonePart then
                teleportPlayer(player, zonePart.Position)
            end
        end)
    end

    for index, pad in pairs(mapReferences.ReturnPads) do
        pad.Touched:Connect(function(part)
            if not part or not part.Parent then
                return
            end

            local player = Players:GetPlayerFromCharacter(part.Parent)
            if not player then
                return
            end

            local basePart = mapReferences.ZonePlatforms[1]
            if basePart then
                teleportPlayer(player, basePart.Position)
            end
        end)
    end
end

mapReferences.DepositPad.Touched:Connect(onDepositTouched)
bindTeleporters()

local function handleHyperSprintToggle(player, desiredState)
    if not UpgradeService.CanUseHyperSprint(player) then
        return false, "Hyper Sprint gamepass required"
    end

    local current = SessionService.GetSetting(player, "HyperSprint") == true
    local target
    if typeof(desiredState) == "boolean" then
        target = desiredState
    else
        target = not current
    end

    SessionService.SetSetting(player, "HyperSprint", target)
    UpgradeService.ApplyCharacterScaling(player)

    return true, target and "Hyper Sprint enabled" or "Hyper Sprint disabled"
end

local function handleAutoCollectorToggle(player, desiredState)
    if not UpgradeService.CanUseAutoCollector(player) then
        return false, "Auto Collector gamepass required"
    end

    local current = SessionService.GetSetting(player, "AutoCollector")
    current = current == nil and true or current == true

    local target
    if typeof(desiredState) == "boolean" then
        target = desiredState
    else
        target = not current
    end

    SessionService.SetSetting(player, "AutoCollector", target)
    OrbManager.UpdateAutoCollector(player)

    return true, target and "Auto Collector enabled" or "Auto Collector disabled"
end

local function handleVipShopPurchase(player, payload)
    if typeof(payload) ~= "table" then
        return false, "Invalid purchase"
    end

    local key = payload.Key
    local item = vipItemsByKey[key]
    if not item then
        return false, "Unavailable"
    end

    if not Monetization.PlayerHasPass(player, "VIP") then
        return false, "VIP exclusive item"
    end

    local session = SessionService.GetSession(player)
    if not session then
        return false, "No session"
    end

    if session.Data.Energy < item.Cost then
        return false, string.format("Need %d Energy", item.Cost)
    end

    SessionService.AdjustEnergy(player, -item.Cost)
    if item.Multiplier and item.Duration then
        local expires = os.time() + item.Duration
        SessionService.AddBoost(player, item.Key, { Multiplier = item.Multiplier, Expires = expires })
    end

    return true, string.format("%s activated!", item.Name)
end

local actionHandlers = {
    UpgradeCapacity = function(player)
        return UpgradeService.HandleUpgrade(player, "Capacity")
    end,
    UpgradeSpeed = function(player)
        return UpgradeService.HandleUpgrade(player, "Speed")
    end,
    UpgradeConverter = function(player)
        return UpgradeService.HandleUpgrade(player, "Converter")
    end,
    UnlockZone = function(player)
        return UpgradeService.HandleZoneUnlock(player)
    end,
    Rebirth = function(player)
        return UpgradeService.HandleRebirth(player)
    end,
    ToggleHyperSprint = function(player, desiredState)
        return handleHyperSprintToggle(player, desiredState)
    end,
    ToggleAutoCollector = function(player, desiredState)
        return handleAutoCollectorToggle(player, desiredState)
    end,
    PurchaseVIPItem = function(player, payload)
        return handleVipShopPurchase(player, payload)
    end,
    __REQUEST_STATE__ = function(player)
        sendState(player)
        return false
    end
}

remotes.ActionRequest.OnServerEvent:Connect(function(player, action, payload)
    if typeof(action) ~= "string" then
        return
    end

    local handler = actionHandlers[action]
    if not handler then
        return
    end

    local success, message = handler(player, payload)
    if message then
        remotes.Notify:FireClient(player, message)
    end

    if success then
        sendState(player)
    end
end)

local function showTutorial(player)
    for index, text in ipairs(Config.TutorialMessages) do
        task.delay(3 + (index - 1) * 6, function()
            if player.Parent then
                remotes.Tutorial:FireClient(player, text)
            end
        end)
    end
end

local function onCharacterAdded(player, character)
    task.wait(0.2)
    UpgradeService.ApplyCharacterScaling(player)
end

local function onPlayerAdded(player)
    createLeaderstats(player)
    local session = SessionService.CreateSession(player)

    Monetization.RegisterPlayer(player)
    Monetization.SyncSession(player)
    OrbManager.RegisterPlayer(player)
    applyOwnedPassPerks(player)

    player.CharacterAdded:Connect(function(character)
        onCharacterAdded(player, character)
    end)

    if player.Character then
        onCharacterAdded(player, player.Character)
    end

    sendState(player)
    showTutorial(player)
end

Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(function(player)
    Monetization.CleanupPlayer(player)
    OrbManager.UnregisterPlayer(player)
end)

for _, player in ipairs(Players:GetPlayers()) do
    onPlayerAdded(player)
end
]]></string>
      </Properties>
    </Item>
    <Item class="Folder" referent="5">
      <Properties>
        <string name="Name">Modules</string>
      </Properties>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">ChatEffects</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local ServerScriptService = game:GetService("ServerScriptService")
local TextChatService = game:GetService("TextChatService")

local ChatEffects = {}

local DEFAULT_COLOR = Color3.fromRGB(255, 226, 110)
local DEFAULT_TAG = "VIP"

local chatService
local success, service = pcall(function()
    local runner = ServerScriptService:FindFirstChild("ChatServiceRunner")
    if runner then
        return require(runner:WaitForChild("ChatService"))
    end
end)

if success then
    chatService = service
end

local vipDataByUserId = {}
local speakerListenerConnected = false

local function ensureSpeakerListener()
    if not chatService or speakerListenerConnected then
        return
    end

    speakerListenerConnected = true
    chatService.SpeakerAdded:Connect(function(speakerName)
        local player = Players:FindFirstChild(speakerName)
        if not player then
            for _, candidate in ipairs(Players:GetPlayers()) do
                if candidate.Name == speakerName then
                    player = candidate
                    break
                end
            end
        end

        if player then
            local info = vipDataByUserId[player.UserId]
            if info then
                task.defer(ChatEffects.ApplyVipFormatting, player, info.Tag, info.Color)
            end
        end
    end)
end

local function colorToHex(color)
    local r = math.floor(math.clamp(color.R, 0, 1) * 255 + 0.5)
    local g = math.floor(math.clamp(color.G, 0, 1) * 255 + 0.5)
    local b = math.floor(math.clamp(color.B, 0, 1) * 255 + 0.5)
    return string.format("#%02X%02X%02X", r, g, b)
end

if TextChatService and TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
    local previousHandler = TextChatService.OnIncomingMessage

    TextChatService.OnIncomingMessage = function(message)
        if previousHandler then
            local result = previousHandler(message)
            if result then
                return result
            end
        end

        if not message.TextSource then
            return nil
        end

        local player = Players:GetPlayerByUserId(message.TextSource.UserId)
        if not player then
            return nil
        end

        local info = vipDataByUserId[player.UserId]
        if not info then
            return nil
        end

        local properties = Instance.new("TextChatMessageProperties")
        local color = info.Color or DEFAULT_COLOR
        local hex = colorToHex(color)
        local tag = info.Tag or DEFAULT_TAG

        properties.PrefixText = string.format("<font color=\"%s\">[%s]</font> %s", hex, tag, message.PrefixText)
        properties.Text = string.format("<font color=\"%s\">%s</font>", hex, message.Text)
        return properties
    end
end

function ChatEffects.ApplyVipFormatting(player, tag, color)
    if not player then
        return
    end

    ensureSpeakerListener()

    local info = {
        Tag = tag or DEFAULT_TAG,
        Color = color or DEFAULT_COLOR
    }
    vipDataByUserId[player.UserId] = info

    if chatService then
        local speaker = chatService:GetSpeaker(player.Name)
        if speaker then
            speaker:SetExtraData("Tags", {{ TagText = info.Tag, TagColor = info.Color }})
            speaker:SetExtraData("ChatColor", info.Color)
        end
    end
end

function ChatEffects.ClearVipFormatting(player)
    if not player then
        return
    end

    vipDataByUserId[player.UserId] = nil

    if chatService then
        local speaker = chatService:GetSpeaker(player.Name)
        if speaker then
            speaker:SetExtraData("Tags", {})
            speaker:SetExtraData("ChatColor", Color3.fromRGB(255, 255, 255))
        end
    end
end

Players.PlayerRemoving:Connect(function(player)
    vipDataByUserId[player.UserId] = nil
end)

return ChatEffects
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">EventService</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Config = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Config"))

local EventService = {}

local remotes
local orbManager
local sendStateCallback
local currentEvent
local nextEventTime = 0

local function cloneTable(original)
    local copy = {}
    for key, value in pairs(original) do
        if typeof(value) == "table" then
            copy[key] = cloneTable(value)
        else
            copy[key] = value
        end
    end
    return copy
end

local function notifyState()
    if not sendStateCallback then
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        sendStateCallback(player)
    end
end

local function scheduleNextEvent()
    local cooldown = Config.DynamicEventCooldown or {}
    local minDelay = math.max(30, cooldown.Min or 60)
    local maxDelay = math.max(minDelay, cooldown.Max or (minDelay + 20))
    nextEventTime = Workspace:GetServerTimeNow() + math.random(minDelay, maxDelay)
end

local function pickEventDefinition()
    local definitions = Config.DynamicEvents or {}
    local keys = {}
    for key in pairs(definitions) do
        table.insert(keys, key)
    end

    if #keys == 0 then
        return nil, nil
    end

    local chosenKey = keys[math.random(1, #keys)]
    return chosenKey, definitions[chosenKey]
end

local function stopBurstThread(eventData)
    if eventData and eventData.Controller then
        eventData.Controller.Cancelled = true
    end
end

local function startBurstLoop(eventData, burstConfig)
    if not burstConfig then
        return
    end

    local controller = eventData.Controller
    task.spawn(function()
        while currentEvent == eventData and controller and not controller.Cancelled do
            if orbManager and orbManager.SpawnBurst then
                orbManager.SpawnBurst(eventData.ZoneIndex, burstConfig)
            end
            local interval = burstConfig.Interval or 15
            task.wait(math.max(4, interval))
        end
    end)
end

local function announce(message)
    if remotes and remotes.Notify and message then
        remotes.Notify:FireAllClients(message)
    end
end

local function beginEvent(key, definition)
    if not definition then
        return
    end

    local zoneIndex = math.random(1, #Config.Zones)
    local zoneConfig = Config.getZone(zoneIndex)
    local zoneName = zoneConfig and zoneConfig.Name or ("Zone " .. zoneIndex)
    local now = Workspace:GetServerTimeNow()
    local duration = definition.Duration or 60

    currentEvent = {
        Key = key,
        Name = definition.Name or key,
        Description = definition.Description or "",
        ZoneIndex = zoneIndex,
        ZoneName = zoneName,
        Color = definition.Color or (zoneConfig and zoneConfig.OrbColor) or Color3.new(1, 1, 1),
        StartedAt = now,
        EndsAt = now + duration,
        Controller = { Cancelled = false }
    }

    if definition.ZoneModifier and orbManager and orbManager.SetEventModifier then
        local modifier = cloneTable(definition.ZoneModifier)
        modifier.ZoneIndex = zoneIndex
        orbManager.SetEventModifier(modifier)
    end

    if definition.Burst and orbManager then
        startBurstLoop(currentEvent, definition.Burst)
    end

    if orbManager and orbManager.SpawnBurst and definition.Burst and definition.Burst.Warmup ~= false then
        orbManager.SpawnBurst(zoneIndex, definition.Burst)
    end

    announce(string.format(definition.Announcement or "%s is surging with energy!", zoneName))
    notifyState()
end

function EventService.StopEvent(message)
    if not currentEvent then
        return
    end

    stopBurstThread(currentEvent)

    if orbManager and orbManager.ClearEventModifier then
        orbManager.ClearEventModifier(currentEvent.ZoneIndex)
    end

    currentEvent = nil
    announce(message)
    notifyState()
    scheduleNextEvent()
end

function EventService.GetEventSummary()
    if not currentEvent then
        return nil
    end

    local now = Workspace:GetServerTimeNow()
    if now >= currentEvent.EndsAt then
        return nil
    end

    return {
        Key = currentEvent.Key,
        Name = currentEvent.Name,
        Description = currentEvent.Description,
        ZoneIndex = currentEvent.ZoneIndex,
        ZoneName = currentEvent.ZoneName,
        Color = currentEvent.Color,
        StartedAt = currentEvent.StartedAt,
        EndsAt = currentEvent.EndsAt
    }
end

local function eventHeartbeat()
    scheduleNextEvent()

    while true do
        task.wait(1)
        local now = Workspace:GetServerTimeNow()

        if currentEvent then
            if now >= currentEvent.EndsAt then
                local finished = currentEvent
                EventService.StopEvent(string.format("%s has settled.", finished.Name))
            end
        elseif now >= nextEventTime then
            local key, definition = pickEventDefinition()
            if key and definition then
                beginEvent(key, definition)
            else
                scheduleNextEvent()
            end
        end
    end
end

function EventService.Init(remoteTable, orbManagerModule, sendState)
    remotes = remoteTable
    orbManager = orbManagerModule
    sendStateCallback = sendState

    if not EventService._initialized then
        EventService._initialized = true
        task.spawn(eventHeartbeat)
    end
end

return EventService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="8">
        <Properties>
          <string name="Name">MapBuilder</string>
          <string name="Source"><![CDATA[local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Config = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Config"))

local MapBuilder = {}

local rng = Random.new()

local function createBillboard(parent, title, description)
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "Billboard"
    billboard.AlwaysOnTop = true
    billboard.Size = UDim2.new(8, 0, 3, 0)
    billboard.ExtentsOffset = Vector3.new(0, 6, 0)
    billboard.Parent = parent

    local titleLabel = Instance.new("TextLabel")
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = title
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.TextScaled = true
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Size = UDim2.new(1, 0, 0.6, 0)
    titleLabel.Position = UDim2.new(0, 0, 0, 0)
    titleLabel.Parent = billboard

    local descLabel = Instance.new("TextLabel")
    descLabel.BackgroundTransparency = 1
    descLabel.TextWrapped = true
    descLabel.Text = description
    descLabel.Font = Enum.Font.Gotham
    descLabel.TextScaled = true
    descLabel.TextColor3 = Color3.fromRGB(213, 233, 255)
    descLabel.Size = UDim2.new(1, 0, 0.4, 0)
    descLabel.Position = UDim2.new(0, 0, 0.6, 0)
    descLabel.Parent = billboard

    return billboard
end

local function createUICorneredPart(name, size, position, material, color, parent)
    local part = Instance.new("Part")
    part.Name = name
    part.Size = size
    part.Position = position
    part.Anchored = true
    part.Material = material or Enum.Material.SmoothPlastic
    part.Color = color or Color3.fromRGB(60, 60, 60)
    part.TopSurface = Enum.SurfaceType.Smooth
    part.BottomSurface = Enum.SurfaceType.Smooth
    part.Parent = parent
    return part
end

local function randomOffset(size, margin)
    margin = margin or 16
    return Vector3.new(
        rng:NextNumber(-1, 1) * (size.X / 2 - margin),
        0,
        rng:NextNumber(-1, 1) * (size.Z / 2 - margin)
    )
end

local function createCrystalCluster(parent, zonePart, baseColor, accentColor)
    local clusterFolder = Instance.new("Folder")
    clusterFolder.Name = "CrystalCluster"
    clusterFolder.Parent = parent

    local offset = randomOffset(zonePart.Size, 18)
    local basePosition = zonePart.Position + offset

    local pedestal = Instance.new("Part")
    pedestal.Name = "Pedestal"
    pedestal.Size = Vector3.new(4, 1.2, 4)
    pedestal.Anchored = true
    pedestal.Material = Enum.Material.Rock
    pedestal.Color = baseColor:lerp(Color3.fromRGB(40, 40, 40), 0.5)
    pedestal.Position = basePosition + Vector3.new(0, zonePart.Size.Y / 2 + pedestal.Size.Y / 2, 0)
    pedestal.Parent = clusterFolder

    for i = 1, rng:NextInteger(3, 5) do
        local shard = Instance.new("Part")
        shard.Name = "Shard" .. i
        shard.Size = Vector3.new(1.4, rng:NextNumber(4, 8), 1.4)
        shard.Material = Enum.Material.Neon
        shard.Color = accentColor or baseColor
        shard.Anchored = true
        shard.CanCollide = false
        local angle = math.rad(rng:NextNumber(-18, 18))
        local rotation = CFrame.Angles(math.rad(rng:NextNumber(-8, 8)), angle, 0)
        local shardPos = basePosition + Vector3.new(rng:NextNumber(-1.4, 1.4), pedestal.Size.Y / 2 + shard.Size.Y / 2, rng:NextNumber(-1.4, 1.4))
        shard.CFrame = CFrame.new(shardPos) * rotation
        shard.Parent = clusterFolder

        local sparkle = Instance.new("Sparkles")
        sparkle.SparkleColor = accentColor or baseColor
        sparkle.Parent = shard
    end

    local light = Instance.new("PointLight")
    light.Color = accentColor or baseColor
    light.Brightness = 1.6
    light.Range = 18
    light.Parent = pedestal

    return clusterFolder
end

local function createTree(parent, zonePart, accentColor)
    local offset = randomOffset(zonePart.Size, 20)
    local basePosition = zonePart.Position + offset

    local trunk = Instance.new("Part")
    trunk.Name = "CrystalTreeTrunk"
    trunk.Size = Vector3.new(1.8, 8, 1.8)
    trunk.Anchored = true
    trunk.Material = Enum.Material.Wood
    trunk.Color = Color3.fromRGB(112, 82, 54)
    trunk.Position = basePosition + Vector3.new(0, zonePart.Size.Y / 2 + trunk.Size.Y / 2, 0)
    trunk.Parent = parent

    local canopy = Instance.new("Part")
    canopy.Name = "CrystalTreeCanopy"
    canopy.Shape = Enum.PartType.Ball
    canopy.Size = Vector3.new(5.6, 5.6, 5.6)
    canopy.Material = Enum.Material.Neon
    canopy.Color = accentColor
    canopy.Anchored = true
    canopy.CanCollide = false
    canopy.Position = trunk.Position + Vector3.new(0, trunk.Size.Y / 2 + canopy.Size.Y / 2 - 1, 0)
    canopy.Parent = parent

    local light = Instance.new("PointLight")
    light.Color = accentColor
    light.Brightness = 1.2
    light.Range = 20
    light.Parent = canopy
end

local function createStonePillar(parent, zonePart, accentColor)
    local offset = randomOffset(zonePart.Size, 18)
    local basePosition = zonePart.Position + offset

    local pillar = Instance.new("Part")
    pillar.Name = "StonePillar"
    pillar.Size = Vector3.new(2.4, rng:NextNumber(12, 18), 2.4)
    pillar.Anchored = true
    pillar.Material = Enum.Material.Slate
    pillar.Color = accentColor:lerp(Color3.fromRGB(50, 50, 50), 0.35)
    pillar.Position = basePosition + Vector3.new(0, zonePart.Size.Y / 2 + pillar.Size.Y / 2, 0)
    pillar.Parent = parent

    local glow = Instance.new("SurfaceLight")
    glow.Face = Enum.NormalId.Top
    glow.Color = accentColor
    glow.Brightness = 2
    glow.Range = 14
    glow.Parent = pillar
end

local function createFlameTorch(parent, zonePart, accentColor)
    local offset = randomOffset(zonePart.Size, 18)
    local basePosition = zonePart.Position + offset

    local base = Instance.new("Part")
    base.Name = "TorchBase"
    base.Size = Vector3.new(2, 4, 2)
    base.Anchored = true
    base.Material = Enum.Material.Slate
    base.Color = accentColor:lerp(Color3.fromRGB(60, 40, 20), 0.7)
    base.Position = basePosition + Vector3.new(0, zonePart.Size.Y / 2 + base.Size.Y / 2, 0)
    base.Parent = parent

    local flame = Instance.new("Fire")
    flame.Color = accentColor
    flame.SecondaryColor = Color3.fromRGB(255, 214, 120)
    flame.Size = 8
    flame.Heat = 10
    flame.Parent = base
end

local function createStormEmitter(parent, zonePart, accentColor)
    local offset = randomOffset(zonePart.Size, 22)
    local basePosition = zonePart.Position + offset

    local spire = Instance.new("Part")
    spire.Name = "StormSpire"
    spire.Size = Vector3.new(1.4, rng:NextNumber(12, 18), 1.4)
    spire.Anchored = true
    spire.Material = Enum.Material.Metal
    spire.Color = Color3.fromRGB(200, 210, 255)
    spire.Position = basePosition + Vector3.new(0, zonePart.Size.Y / 2 + spire.Size.Y / 2, 0)
    spire.Parent = parent

    local spark = Instance.new("ParticleEmitter")
    spark.LightEmission = 1
    spark.Rate = 40
    spark.Speed = NumberRange.new(6, 9)
    spark.Lifetime = NumberRange.new(0.4, 0.6)
    spark.Color = ColorSequence.new(accentColor)
    spark.Size = NumberSequence.new({ NumberSequenceKeypoint.new(0, 0.6), NumberSequenceKeypoint.new(1, 0) })
    spark.Parent = spire

    local light = Instance.new("PointLight")
    light.Color = accentColor
    light.Brightness = 3
    light.Range = 22
    light.Parent = spire
end

local function createLagoonPool(parent, zonePart, accentColor)
    local offset = randomOffset(zonePart.Size, 24)
    local position = zonePart.Position + offset

    local pool = Instance.new("Part")
    pool.Name = "LagoonPool"
    pool.Size = Vector3.new(14, 1.2, 14)
    pool.Anchored = true
    pool.Material = Enum.Material.Water
    pool.Color = accentColor
    pool.Transparency = 0.35
    pool.Position = position + Vector3.new(0, zonePart.Size.Y / 2 + 0.6, 0)
    pool.Parent = parent

    local glow = Instance.new("SurfaceLight")
    glow.Brightness = 1.4
    glow.Range = 18
    glow.Color = accentColor
    glow.Parent = pool
end

local function createVoidPrism(parent, zonePart, accentColor)
    local offset = randomOffset(zonePart.Size, 22)
    local basePosition = zonePart.Position + offset

    local prism = Instance.new("Part")
    prism.Name = "VoidPrism"
    prism.Size = Vector3.new(2.6, rng:NextNumber(10, 16), 2.6)
    prism.Anchored = true
    prism.Material = Enum.Material.Neon
    prism.Color = accentColor
    prism.Position = basePosition + Vector3.new(0, zonePart.Size.Y / 2 + prism.Size.Y / 2, 0)
    prism.Parent = parent

    local aura = Instance.new("ParticleEmitter")
    aura.LightEmission = 1
    aura.Rate = 20
    aura.Lifetime = NumberRange.new(1.2, 1.6)
    aura.Speed = NumberRange.new(0.4, 1)
    aura.Rotation = NumberRange.new(0, 360)
    aura.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.2, 1.2),
        NumberSequenceKeypoint.new(1, 0)
    })
    aura.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, accentColor),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))
    })
    aura.Parent = prism
end

local function decorateZone(zoneFolder, zonePart, zoneConfig)
    local props = zoneConfig.Props or {}
    local accent = zoneConfig.AccentColor or zoneConfig.OrbColor

    if props.Crystals then
        local count = typeof(props.Crystals) == "number" and props.Crystals or 4
        for _ = 1, count do
            createCrystalCluster(zoneFolder, zonePart, zoneConfig.OrbColor, accent)
        end
    end

    if props.Trees then
        local count = typeof(props.Trees) == "number" and props.Trees or 5
        for _ = 1, count do
            createTree(zoneFolder, zonePart, accent)
        end
    end

    if props.Pillars then
        local count = typeof(props.Pillars) == "number" and props.Pillars or 3
        for _ = 1, count do
            createStonePillar(zoneFolder, zonePart, accent)
        end
    end

    if props.Flames then
        local count = typeof(props.Flames) == "number" and props.Flames or 2
        for _ = 1, count do
            createFlameTorch(zoneFolder, zonePart, accent)
        end
    end

    if props.Storm then
        local count = typeof(props.Storm) == "number" and props.Storm or 3
        for _ = 1, count do
            createStormEmitter(zoneFolder, zonePart, accent)
        end
    end

    if props.Water then
        local count = typeof(props.Water) == "number" and props.Water or 3
        for _ = 1, count do
            createLagoonPool(zoneFolder, zonePart, accent)
        end
    end

    if props.Void then
        local count = typeof(props.Void) == "number" and props.Void or 4
        for _ = 1, count do
            createVoidPrism(zoneFolder, zonePart, accent)
        end
    end
end

local function createHoverCrystal(parent, position, color)
    local crystal = Instance.new("Part")
    crystal.Name = "HoverCrystal"
    crystal.Size = Vector3.new(3, 7, 3)
    crystal.Anchored = true
    crystal.CanCollide = false
    crystal.Material = Enum.Material.Neon
    crystal.Color = color
    crystal.CFrame = CFrame.new(position) * CFrame.Angles(0, math.rad(rng:NextNumber(0, 360)), math.rad(18))
    crystal.Parent = parent

    local sparkles = Instance.new("Sparkles")
    sparkles.SparkleColor = color
    sparkles.Parent = crystal

    local light = Instance.new("PointLight")
    light.Color = color
    light.Brightness = 2
    light.Range = 24
    light.Parent = crystal
end

function MapBuilder.build()
    local existing = Workspace:FindFirstChild("GeneratedMap")
    if existing then
        existing:Destroy()
    end

    local mapFolder = Instance.new("Folder")
    mapFolder.Name = "GeneratedMap"
    mapFolder.Parent = Workspace

    local zonesFolder = Instance.new("Folder")
    zonesFolder.Name = "Zones"
    zonesFolder.Parent = mapFolder

    local teleporterFolder = Instance.new("Folder")
    teleporterFolder.Name = "TeleportPads"
    teleporterFolder.Parent = mapFolder

    local basePlatform = createUICorneredPart(
        "BasePlatform",
        Config.ZoneSize + Vector3.new(40, 2, 40),
        Vector3.new(0, Config.ZoneY, 0),
        Enum.Material.Grass,
        Color3.fromRGB(44, 118, 72),
        mapFolder
    )

    local baseRim = createUICorneredPart(
        "BaseRim",
        basePlatform.Size + Vector3.new(18, 0.6, 18),
        basePlatform.Position + Vector3.new(0, -basePlatform.Size.Y / 2 + 0.3, 0),
        Enum.Material.Rock,
        Color3.fromRGB(58, 66, 84),
        mapFolder
    )

    local waterRing = createUICorneredPart(
        "WaterRing",
        basePlatform.Size + Vector3.new(80, 0.8, 80),
        basePlatform.Position + Vector3.new(0, -basePlatform.Size.Y / 2 - 0.4, 0),
        Enum.Material.Water,
        Color3.fromRGB(38, 108, 158),
        mapFolder
    )
    waterRing.Transparency = 0.4

    local spawnLocation = Instance.new("SpawnLocation")
    spawnLocation.Name = "Spawn"
    spawnLocation.Size = Vector3.new(8, 1, 8)
    spawnLocation.Position = basePlatform.Position + Vector3.new(0, basePlatform.Size.Y / 2 + 0.6, 0)
    spawnLocation.Anchored = true
    spawnLocation.Neutral = true
    spawnLocation.Transparency = 1
    spawnLocation.CanCollide = false
    spawnLocation.Parent = mapFolder

    local depositPad = Instance.new("Part")
    depositPad.Name = "DepositPad"
    depositPad.Size = Config.DepositPadSize
    depositPad.Position = basePlatform.Position + Vector3.new(0, basePlatform.Size.Y / 2 + 0.6, -24)
    depositPad.Anchored = true
    depositPad.Material = Enum.Material.Neon
    depositPad.Color = Color3.fromRGB(255, 215, 79)
    depositPad.TopSurface = Enum.SurfaceType.Smooth
    depositPad.BottomSurface = Enum.SurfaceType.Smooth
    depositPad.Parent = mapFolder

    createBillboard(depositPad, "Deposit", "Convert shards into Energy here")

    local upgradePedestal = createUICorneredPart(
        "UpgradePedestal",
        Vector3.new(16, 1.2, 16),
        basePlatform.Position + Vector3.new(0, basePlatform.Size.Y / 2 + 0.6, 26),
        Enum.Material.Metal,
        Color3.fromRGB(78, 88, 142),
        mapFolder
    )

    createBillboard(upgradePedestal, "Upgrades", "Use the UI to purchase upgrades")

    local teleporterRing = createUICorneredPart(
        "TeleporterRing",
        Vector3.new(70, 1.2, 70),
        basePlatform.Position + Vector3.new(0, basePlatform.Size.Y / 2 + 0.4, 0),
        Enum.Material.ForceField,
        Color3.fromRGB(137, 155, 255),
        mapFolder
    )
    teleporterRing.Transparency = 0.25

    for index = 1, 6 do
        local angle = math.rad((index - 1) * 60)
        local radius = 36
        local height = teleporterRing.Position.Y + 10 + rng:NextNumber(-2, 4)
        local position = teleporterRing.Position + Vector3.new(math.cos(angle) * radius, height, math.sin(angle) * radius)
        createHoverCrystal(mapFolder, position, Color3.fromRGB(140, 198, 255))
    end

    local teleporterPads = {}
    local returnPads = {}
    local zonePlatforms = {}
    local orbContainers = {}

    for index, zoneConfig in ipairs(Config.Zones) do
        local zoneFolder = Instance.new("Folder")
        zoneFolder.Name = string.format("Zone_%d", index)
        zoneFolder.Parent = zonesFolder

        local zonePart
        if index == 1 then
            zonePart = basePlatform
        else
            zonePart = Instance.new("Part")
            zonePart.Name = zoneConfig.Name:gsub(" ", "") .. "Platform"
            zonePart.Size = Config.ZoneSize + Vector3.new(0, 1, 0)
            local height = (zoneConfig.Height or 0)
            zonePart.Position = Vector3.new((index - 1) * Config.ZoneSpacing, Config.ZoneY + height, 0)
            zonePart.Anchored = true
            zonePart.Material = zoneConfig.TerrainMaterial or Enum.Material.SmoothPlastic
            zonePart.Color = zoneConfig.TerrainColor or zoneConfig.OrbColor:lerp(Color3.fromRGB(40, 40, 40), 0.5)
            zonePart.TopSurface = Enum.SurfaceType.Smooth
            zonePart.BottomSurface = Enum.SurfaceType.Smooth
            zonePart.Parent = zoneFolder

            local trim = Instance.new("Part")
            trim.Name = "ZoneTrim"
            trim.Size = zonePart.Size + Vector3.new(12, 0.6, 12)
            trim.Position = zonePart.Position + Vector3.new(0, -zonePart.Size.Y / 2 + 0.3, 0)
            trim.Anchored = true
            trim.Material = Enum.Material.Slate
            trim.Color = (zoneConfig.AccentColor or zoneConfig.OrbColor):lerp(Color3.fromRGB(20, 20, 20), 0.3)
            trim.Parent = zoneFolder

            decorateZone(zoneFolder, zonePart, zoneConfig)
        end
        zonePlatforms[index] = zonePart

        local orbFolder = Instance.new("Folder")
        orbFolder.Name = "Orbs"
        orbFolder.Parent = zoneFolder
        orbContainers[index] = orbFolder

        if index > 1 then
            local portal = Instance.new("Part")
            portal.Name = zoneConfig.Name:gsub(" ", "") .. "Portal"
            portal.Size = Config.TeleportPadSize + Vector3.new(4, 0, 4)
            portal.Anchored = true
            portal.CanCollide = false
            portal.Material = Enum.Material.Neon
            portal.Color = zoneConfig.AccentColor or zoneConfig.OrbColor
            local angle = math.rad((index - 2) * (360 / math.max(1, (#Config.Zones - 1))))
            local radius = 32
            portal.Position = teleporterRing.Position + Vector3.new(math.cos(angle) * radius, 0.8, math.sin(angle) * radius)
            portal.Parent = teleporterFolder

            local swirl = Instance.new("ParticleEmitter")
            swirl.LightEmission = 1
            swirl.Speed = NumberRange.new(2, 4)
            swirl.Lifetime = NumberRange.new(0.6, 0.8)
            swirl.Rate = 40
            swirl.Rotation = NumberRange.new(0, 360)
            swirl.Color = ColorSequence.new(zoneConfig.AccentColor or zoneConfig.OrbColor)
            swirl.Size = NumberSequence.new({
                NumberSequenceKeypoint.new(0, 0),
                NumberSequenceKeypoint.new(0.2, 3.4),
                NumberSequenceKeypoint.new(1, 0)
            })
            swirl.Parent = portal

            createBillboard(portal, zoneConfig.Name, string.format("Unlock for %d Energy", zoneConfig.UnlockCost))
            teleporterPads[index] = portal
        end

        local returnPad = Instance.new("Part")
        returnPad.Name = zoneConfig.Name:gsub(" ", "") .. "ReturnPad"
        returnPad.Size = Config.TeleportPadSize
        local offsetX = -Config.ZoneSize.X / 2 + 14
        local offsetZ = Config.ZoneSize.Z / 2 - 14
        returnPad.Position = zonePart.Position + Vector3.new(offsetX, zonePart.Size.Y / 2 + 0.6, offsetZ)
        returnPad.Anchored = true
        returnPad.CanCollide = false
        returnPad.Material = Enum.Material.Neon
        returnPad.Color = Color3.fromRGB(255, 255, 255)
        returnPad.Parent = zoneFolder
        createBillboard(returnPad, "Return", "Step to teleport back")
        returnPads[index] = returnPad
    end

    return {
        MapFolder = mapFolder,
        DepositPad = depositPad,
        TeleporterPads = teleporterPads,
        ReturnPads = returnPads,
        ZonePlatforms = zonePlatforms,
        OrbContainers = orbContainers
    }
end

return MapBuilder
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="9">
        <Properties>
          <string name="Name">Monetization</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Config = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Config"))
local SessionService = require(script.Parent:WaitForChild("SessionService"))

local Monetization = {}

local remotes = nil
local stateUpdateCallback = nil

local passOwnership = {}
local passLookupById = {}
local productLookupById = {}
local productLookupByKey = {}

local passUnlockedCallbacks = {}

local function buildLookups()
    passLookupById = {}
    productLookupById = {}
    productLookupByKey = {}

    for key, passInfo in pairs(Config.Gamepasses) do
        if passInfo.Id and passInfo.Id > 0 then
            passLookupById[passInfo.Id] = key
        end
    end

    for categoryName, items in pairs(Config.DeveloperProducts) do
        for _, info in ipairs(items) do
            local entry = { Category = categoryName, Info = info }
            productLookupByKey[info.Key] = entry
            if info.Id and info.Id > 0 then
                productLookupById[info.Id] = entry
            end
        end
    end
end

local function notify(player, message)
    if remotes and remotes.Notify then
        remotes.Notify:FireClient(player, message)
    end
end

local function updateState(player)
    if stateUpdateCallback then
        stateUpdateCallback(player)
    end
end

local function setPass(player, key, value, suppressFeedback)
    passOwnership[player] = passOwnership[player] or {}
    passOwnership[player][key] = value or nil

    local session = SessionService.GetSession(player)
    if session then
        session.OwnedGamepasses = session.OwnedGamepasses or {}
        session.OwnedGamepasses[key] = value and true or nil
    end

    player:SetAttribute("Gamepass_" .. key, value and true or false)

    if value then
        if not suppressFeedback then
            notify(player, string.format("%s unlocked!", Config.Gamepasses[key].Name))
        end

        for _, callback in ipairs(passUnlockedCallbacks) do
            task.defer(callback, player, key)
        end
    end

    if not suppressFeedback then
        updateState(player)
    end
end

function Monetization.SetRemotes(remoteTable)
    remotes = remoteTable
    buildLookups()
end

function Monetization.SetStateUpdateCallback(callback)
    stateUpdateCallback = callback
end

function Monetization.OnPassUnlocked(callback)
    table.insert(passUnlockedCallbacks, callback)
end

function Monetization.PlayerHasPass(player, key)
    local owned = passOwnership[player]
    return owned and owned[key] == true or false
end

function Monetization.GetOwnedPasses(player)
    return passOwnership[player] or {}
end

function Monetization.RegisterPlayer(player)
    passOwnership[player] = passOwnership[player] or {}
    local session = SessionService.GetSession(player)
    if session then
        session.OwnedGamepasses = session.OwnedGamepasses or {}
    end

    for key, info in pairs(Config.Gamepasses) do
        if info.Id and info.Id > 0 then
            local success, owns = pcall(MarketplaceService.UserOwnsGamePassAsync, MarketplaceService, player.UserId, info.Id)
            if success and owns then
                setPass(player, key, true, true)
            end
        end
    end

    updateState(player)
end

function Monetization.SyncSession(player)
    local session = SessionService.GetSession(player)
    if not session then
        return
    end

    session.OwnedGamepasses = session.OwnedGamepasses or {}
    local owned = passOwnership[player]
    if owned then
        for key, value in pairs(owned) do
            if value then
                session.OwnedGamepasses[key] = true
            end
        end
    end
end

function Monetization.CleanupPlayer(player)
    passOwnership[player] = nil
end

local function handlePurchaseRequest(player, payload)
    if typeof(payload) ~= "table" then
        return
    end

    local requestType = payload.Type
    if requestType == "Gamepass" then
        local passKey = payload.Key
        local info = Config.Gamepasses[passKey]
        if info and info.Id and info.Id > 0 then
            MarketplaceService:PromptGamePassPurchase(player, info.Id)
        else
            notify(player, "Gamepass ID not set yet.")
        end
    elseif requestType == "Product" then
        local productKey = payload.Key
        local entry = productLookupByKey[productKey]
        if entry and entry.Info.Id and entry.Info.Id > 0 then
            MarketplaceService:PromptProductPurchase(player, entry.Info.Id)
        else
            notify(player, "Product ID not set yet.")
        end
    end
end

local function awardProduct(player, entry)
    local session = SessionService.GetSession(player)
    if not session then
        return Enum.ProductPurchaseDecision.NotProcessedYet
    end

    local info = entry.Info
    if entry.Category == "EnergyPacks" then
        SessionService.AdjustEnergy(player, info.Amount)
        notify(player, string.format("+%d Energy!", info.Amount))
        updateState(player)
    elseif entry.Category == "Boosts" then
        local expiresAt = os.time() + info.Duration
        SessionService.AddBoost(player, info.Key, { Multiplier = info.Multiplier, Expires = expiresAt })
        notify(player, string.format("%s activated!", info.Name))
        updateState(player)
    end

    return Enum.ProductPurchaseDecision.PurchaseGranted
end

local function processReceipt(receiptInfo)
    local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
    if not player then
        return Enum.ProductPurchaseDecision.NotProcessedYet
    end

    local entry = productLookupById[receiptInfo.ProductId]
    if not entry then
        return Enum.ProductPurchaseDecision.NotProcessedYet
    end

    return awardProduct(player, entry)
end

local function onGamePassFinished(player, gamePassId, wasPurchased)
    if not wasPurchased then
        return
    end

    local passKey = passLookupById[gamePassId]
    if passKey then
        setPass(player, passKey, true)
    end
end

function Monetization.Init(remoteTable)
    Monetization.SetRemotes(remoteTable)

    if not remotes then
        return
    end

    remotes.PurchaseRequest.OnServerEvent:Connect(handlePurchaseRequest)
    MarketplaceService.ProcessReceipt = processReceipt
    MarketplaceService.PromptGamePassPurchaseFinished:Connect(onGamePassFinished)
end

return Monetization
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="10">
        <Properties>
          <string name="Name">OrbManager</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Config = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Config"))
local SessionService = require(script.Parent:WaitForChild("SessionService"))
local UpgradeService = require(script.Parent:WaitForChild("UpgradeService"))

local OrbManager = {}

local remotes
local mapReferences
local monetization
local stateUpdateCallback

local activeOrbs = {}
local spawnThreads = {}
local autoCollectorThreads = {}
local eventModifier

local function cloneTable(tbl)
    local copy = {}
    for key, value in pairs(tbl) do
        if typeof(value) == "table" then
            copy[key] = cloneTable(value)
        else
            copy[key] = value
        end
    end
    return copy
end

local function fireStateUpdate(player)
    if stateUpdateCallback then
        stateUpdateCallback(player)
    end
end

local function randomOrbPosition(zonePart, heightOffset)
    local size = zonePart.Size
    local margin = 8
    local xRange = math.max(4, size.X - margin)
    local zRange = math.max(4, size.Z - margin)
    local offsetX = (math.random() - 0.5) * xRange
    local offsetZ = (math.random() - 0.5) * zRange
    local baseY = zonePart.Position.Y + (zonePart.Size.Y / 2)
    return zonePart.Position + Vector3.new(offsetX, (heightOffset or 0) + baseY + 2.6, offsetZ)
end

local function markOrbDestroyed(zoneIndex, orb)
    if activeOrbs[zoneIndex] then
        activeOrbs[zoneIndex][orb] = nil
    end
end

local function destroyOrb(zoneIndex, orb)
    markOrbDestroyed(zoneIndex, orb)
    if orb and orb.Parent then
        orb:Destroy()
    end
end

local function collectOrb(player, orb)
    if not orb or not orb.Parent then
        return
    end

    local zoneIndex = orb:GetAttribute("ZoneIndex")
    local value = orb:GetAttribute("Value") or 1
    local isRare = orb:GetAttribute("IsRare") == true
    local rareValue = orb:GetAttribute("RareValue") or value

    local session = SessionService.GetSession(player)
    if not session then
        return
    end

    if session.Data.ZoneLevel < zoneIndex then
        return
    end

    local capacity = UpgradeService.GetCapacity(player)
    if capacity ~= math.huge and session.Inventory + value > capacity then
        return
    end

    if monetization and monetization.PlayerHasPass(player, "LUCKY_AURA") then
        local luckBonus = Config.Gamepasses.LUCKY_AURA.LuckBonus or 0
        if not isRare and luckBonus > 0 then
            if math.random() < luckBonus then
                isRare = true
                value = rareValue
            end
        end
    end

    local comboCount = SessionService.RegisterComboHit(player)
    local comboInfo = SessionService.GetComboInfo(player)

    orb:SetAttribute("Collected", true)
    destroyOrb(zoneIndex, orb)

    SessionService.AddInventory(player, value)

    if remotes and remotes.Notify and comboCount > 1 then
        local threshold = (Config.Combo and Config.Combo.NotifyThreshold) or 5
        if comboCount % threshold == 0 then
            local bonusPercent = math.floor((comboInfo.Multiplier - 1) * 100)
            remotes.Notify:FireClient(
                player,
                string.format("Combo x%d! +%d%% deposit bonus", comboCount, bonusPercent)
            )
        end
    end

    fireStateUpdate(player)
end

local function onOrbTouched(orb, otherPart)
    if orb:GetAttribute("Collected") then
        return
    end

    local character = otherPart.Parent
    if not character then
        return
    end

    local player = Players:GetPlayerFromCharacter(character)
    if not player then
        return
    end

    collectOrb(player, orb)
end

local function getActiveModifier(zoneIndex)
    if eventModifier and eventModifier.ZoneIndex == zoneIndex then
        return eventModifier
    end
end

local function spawnOrbInZone(zoneIndex, overrides)
    local zonePart = mapReferences.ZonePlatforms[zoneIndex]
    local container = mapReferences.OrbContainers[zoneIndex]
    local zoneConfig = Config.getZone(zoneIndex)

    if not zonePart or not container or not zoneConfig then
        return
    end

    local modifier = getActiveModifier(zoneIndex)
    local orb = Instance.new("Part")
    orb.Name = overrides and overrides.Name or "EnergyOrb"
    orb.Shape = overrides and overrides.Shape or Enum.PartType.Ball
    orb.Size = overrides and overrides.Size or Vector3.new(2.8, 2.8, 2.8)
    orb.Material = overrides and overrides.Material or Enum.Material.Neon
    orb.Anchored = true
    orb.CanCollide = false
    orb.Position = randomOrbPosition(zonePart, overrides and overrides.HeightOffset or 0)

    local baseValue = overrides and overrides.Value or zoneConfig.OrbValue
    local rareValue = overrides and overrides.RareValue or zoneConfig.RareOrbValue
    local valueMultiplier = 1

    if modifier and modifier.ValueMultiplier then
        valueMultiplier *= modifier.ValueMultiplier
    end
    if overrides and overrides.ValueMultiplier then
        valueMultiplier *= overrides.ValueMultiplier
    end

    baseValue = math.max(1, math.floor(baseValue * valueMultiplier))
    rareValue = math.max(baseValue + 1, math.floor(rareValue * valueMultiplier))

    local rareChance = overrides and overrides.RareChance or zoneConfig.RareChance
    if modifier and modifier.RareChanceBonus then
        rareChance += modifier.RareChanceBonus
    end
    if overrides and overrides.RareChanceBonus then
        rareChance += overrides.RareChanceBonus
    end
    rareChance = math.clamp(rareChance, 0, 1)

    local isRare
    if overrides and overrides.ForceRare then
        isRare = true
    else
        isRare = math.random() < rareChance
    end

    local color = overrides and overrides.Color or zoneConfig.OrbColor
    if modifier and modifier.ColorShift then
        local blend = modifier.ColorBlend or 0.45
        color = color:Lerp(modifier.ColorShift, blend)
    end

    if isRare and not (overrides and overrides.KeepRareColor) then
        color = color:lerp(Color3.fromRGB(255, 255, 255), 0.35)
    end

    orb.Color = color

    orb:SetAttribute("ZoneIndex", zoneIndex)
    local storedValue = isRare and rareValue or baseValue
    orb:SetAttribute("Value", storedValue)
    orb:SetAttribute("RareValue", rareValue)
    orb:SetAttribute("IsRare", isRare)
    if overrides and overrides.IsEvent then
        orb:SetAttribute("IsEvent", true)
    end

    local shouldGlow = (modifier and modifier.Glow) or (overrides and overrides.Glow) or isRare
    if shouldGlow then
        local light = Instance.new("PointLight")
        light.Color = overrides and overrides.LightColor or color
        light.Brightness = overrides and overrides.LightBrightness or (isRare and 2.2 or 1.6)
        light.Range = overrides and overrides.LightRange or 16
        light.Parent = orb
    end

    if overrides and overrides.Sparkle then
        local sparkle = Instance.new("Sparkles")
        sparkle.SparkleColor = overrides.SparkleColor or color
        sparkle.Parent = orb
    end

    orb.Touched:Connect(function(part)
        onOrbTouched(orb, part)
    end)

    orb.Parent = container
    activeOrbs[zoneIndex] = activeOrbs[zoneIndex] or {}
    activeOrbs[zoneIndex][orb] = true

    if overrides and overrides.Duration then
        task.delay(overrides.Duration, function()
            destroyOrb(zoneIndex, orb)
        end)
    end
end

local function maintainZone(zoneIndex)
    spawnThreads[zoneIndex] = task.spawn(function()
        local zoneConfig = Config.getZone(zoneIndex)
        if not zoneConfig then
            return
        end

        while true do
            local container = mapReferences.OrbContainers[zoneIndex]
            if not container then
                break
            end

            local modifier = getActiveModifier(zoneIndex)
            local densityMultiplier = modifier and (modifier.TargetMultiplier or 1) or 1
            local baseTarget = zoneConfig.OrbDensity
            local computedTarget = math.floor(baseTarget * densityMultiplier + 0.5)
            if densityMultiplier < 1 then
                computedTarget = math.max(computedTarget, math.floor(baseTarget * 0.6))
            end
            local target = math.clamp(computedTarget, 6, Config.MaxOrbsPerZone * 2)
            if target <= 0 then
                target = math.min(baseTarget, Config.MaxOrbsPerZone)
            end

            local existing = #container:GetChildren()
            if existing < target then
                spawnOrbInZone(zoneIndex)
            end

            local rateMultiplier = modifier and (modifier.SpawnRateMultiplier or 1) or 1
            local waitTime = math.max(0.5, (Config.OrbRespawnSeconds / rateMultiplier) + math.random())
            task.wait(waitTime)
        end
    end)
end

local function stopAutoCollector(player)
    local thread = autoCollectorThreads[player]
    if thread then
        thread.cancelled = true
        autoCollectorThreads[player] = nil
    end
end

local function runAutoCollector(player)
    stopAutoCollector(player)

    autoCollectorThreads[player] = {}
    local threadRef = autoCollectorThreads[player]

    task.spawn(function()
        local settings = Config.Gamepasses.AUTO_COLLECTOR
        while threadRef and not threadRef.cancelled do
            if not monetization or not monetization.PlayerHasPass(player, "AUTO_COLLECTOR") then
                break
            end

            local settingEnabled = SessionService.GetSetting(player, "AutoCollector")
            if settingEnabled == false then
                break
            end

            local character = player.Character
            local root = character and character:FindFirstChild("HumanoidRootPart")
            if root then
                local radius = settings and settings.Radius or 12
                for zoneIndex, orbs in pairs(activeOrbs) do
                    for orb in pairs(orbs) do
                        if orb.Parent and not orb:GetAttribute("Collected") then
                            local distance = (orb.Position - root.Position).Magnitude
                            if distance <= radius then
                                collectOrb(player, orb)
                            end
                        end
                    end
                end
            end

            local interval = settings and settings.Interval or 2
            task.wait(interval)
        end
        autoCollectorThreads[player] = nil
    end)
end

local function isAutoCollectorEnabled(player)
    if not monetization or not monetization.PlayerHasPass(player, "AUTO_COLLECTOR") then
        return false
    end

    local setting = SessionService.GetSetting(player, "AutoCollector")
    if setting == nil then
        return true
    end

    return setting == true
end

local function ensureAutoCollector(player)
    if isAutoCollectorEnabled(player) then
        runAutoCollector(player)
    else
        stopAutoCollector(player)
    end
end

function OrbManager.Init(mapRefs, remoteTable, monetizationModule, updateCallback)
    mapReferences = mapRefs
    remotes = remoteTable
    monetization = monetizationModule
    stateUpdateCallback = updateCallback
    eventModifier = nil

    if monetization and monetization.OnPassUnlocked then
        monetization.OnPassUnlocked(function(player, passKey)
            if passKey == "AUTO_COLLECTOR" then
                task.defer(ensureAutoCollector, player)
            end
        end)
    end

    for index in ipairs(Config.Zones) do
        maintainZone(index)
    end
end

function OrbManager.RegisterPlayer(player)
    ensureAutoCollector(player)

    player.CharacterAdded:Connect(function()
        task.defer(ensureAutoCollector, player)
    end)
end

function OrbManager.UnregisterPlayer(player)
    stopAutoCollector(player)
end

function OrbManager.UpdateAutoCollector(player)
    ensureAutoCollector(player)
end

function OrbManager.SetEventModifier(modifier)
    if typeof(modifier) ~= "table" or not modifier.ZoneIndex then
        eventModifier = nil
        return
    end

    eventModifier = cloneTable(modifier)
end

function OrbManager.ClearEventModifier(zoneIndex)
    if not eventModifier then
        return
    end

    if not zoneIndex or eventModifier.ZoneIndex == zoneIndex then
        eventModifier = nil
    end
end

function OrbManager.GetEventModifier()
    if not eventModifier then
        return nil
    end

    return cloneTable(eventModifier)
end

function OrbManager.SpawnBurst(zoneIndex, burstConfig)
    if not burstConfig then
        return
    end

    local count = math.max(1, math.floor(burstConfig.Count or 3))
    for _ = 1, count do
        spawnOrbInZone(zoneIndex, {
            Name = burstConfig.Name or "EventCrystal",
            Size = burstConfig.Size,
            Material = burstConfig.Material,
            ValueMultiplier = burstConfig.ValueMultiplier or 4,
            Duration = burstConfig.Duration or 12,
            Color = burstConfig.Color,
            Glow = burstConfig.Glow ~= false,
            Sparkle = burstConfig.Sparkle ~= false,
            SparkleColor = burstConfig.SparkleColor,
            LightBrightness = burstConfig.LightBrightness,
            LightRange = burstConfig.LightRange,
            HeightOffset = burstConfig.HeightOffset or 3,
            ForceRare = burstConfig.ForceRare ~= false,
            RareChanceBonus = burstConfig.RareChanceBonus,
            IsEvent = true
        })
    end
end

return OrbManager
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="11">
        <Properties>
          <string name="Name">Remotes</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Remotes = {}

local function getOrCreateRemote(folder, className, name)
    local remote = folder:FindFirstChild(name)
    if not remote then
        remote = Instance.new(className)
        remote.Name = name
        remote.Parent = folder
    end

    return remote
end

function Remotes.get()
    local container = ReplicatedStorage:FindFirstChild("Remotes")
    if not container then
        container = Instance.new("Folder")
        container.Name = "Remotes"
        container.Parent = ReplicatedStorage
    end

    local eventsFolder = container:FindFirstChild("Events")
    if not eventsFolder then
        eventsFolder = Instance.new("Folder")
        eventsFolder.Name = "Events"
        eventsFolder.Parent = container
    end

    local remotes = {
        StateUpdate = getOrCreateRemote(eventsFolder, "RemoteEvent", "StateUpdate"),
        Notify = getOrCreateRemote(eventsFolder, "RemoteEvent", "Notify"),
        ActionRequest = getOrCreateRemote(eventsFolder, "RemoteEvent", "ActionRequest"),
        PurchaseRequest = getOrCreateRemote(eventsFolder, "RemoteEvent", "PurchaseRequest"),
        Tutorial = getOrCreateRemote(eventsFolder, "RemoteEvent", "Tutorial")
    }

    return remotes
end

return Remotes
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="12">
        <Properties>
          <string name="Name">SessionService</string>
          <string name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Config = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Config"))

local SessionService = {}

local DATASTORE_NAME = "CrystalRush_PlayerData_V1"
local dataStore = DataStoreService:GetDataStore(DATASTORE_NAME)

local DEFAULT_DATA = {
    Energy = 0,
    TotalEnergy = 0,
    CapacityLevel = 1,
    SpeedLevel = 1,
    ConverterLevel = 1,
    ZoneLevel = 1,
    Rebirths = 0,
    Settings = {
        HyperSprint = false,
        AutoCollector = true
    },
    TutorialStep = 0
}

local sessions = {}

local function deepCopy(original)
    local copy = {}
    for key, value in pairs(original) do
        if typeof(value) == "table" then
            copy[key] = deepCopy(value)
        else
            copy[key] = value
        end
    end
    return copy
end

local function createDefaultData()
    return deepCopy(DEFAULT_DATA)
end

local function ensureSettings(session)
    session.Data.Settings = session.Data.Settings or {}
    if session.Data.Settings.HyperSprint == nil then
        session.Data.Settings.HyperSprint = false
    end
    if session.Data.Settings.AutoCollector == nil then
        session.Data.Settings.AutoCollector = true
    end
end

local function ensureCombo(session)
    session.Combo = session.Combo or { Count = 0, Expires = 0, Best = 0 }
    return session.Combo
end

local function getKey(player)
    return string.format("Player_%d", player.UserId)
end

function SessionService.GetSession(player)
    return sessions[player]
end

function SessionService.GetData(player)
    local session = sessions[player]
    return session and session.Data
end

local function loadData(player)
    local key = getKey(player)
    local success, stored = pcall(function()
        return dataStore:GetAsync(key)
    end)

    if success and stored then
        local newData = createDefaultData()
        for k, v in pairs(stored) do
            if newData[k] ~= nil then
                if typeof(newData[k]) == "table" and typeof(v) == "table" then
                    newData[k] = deepCopy(v)
                else
                    newData[k] = v
                end
            end
        end
        return newData
    end

    if not success then
        warn("[SessionService] Failed to load data for", player.Name, stored)
    end

    return createDefaultData()
end

function SessionService.CreateSession(player)
    local data = loadData(player)

    local session = {
        Player = player,
        Data = data,
        Inventory = 0,
        Boosts = {},
        OwnedGamepasses = {},
        LastSave = os.time(),
        LastDeposit = 0
    }

    ensureSettings(session)
    ensureCombo(session)
    sessions[player] = session
    return session
end

local function serializeData(data)
    local serialized = {}
    for k, v in pairs(data) do
        if typeof(v) == "table" then
            serialized[k] = deepCopy(v)
        else
            serialized[k] = v
        end
    end
    return serialized
end

function SessionService.SaveSession(player)
    local session = sessions[player]
    if not session then
        return
    end

    local key = getKey(player)
    local serialized = serializeData(session.Data)

    local success, err = pcall(function()
        dataStore:SetAsync(key, serialized)
    end)

    if not success then
        warn("[SessionService] Failed to save data for", player.Name, err)
    else
        session.LastSave = os.time()
    end
end

function SessionService.RemoveSession(player)
    sessions[player] = nil
end

function SessionService.AdjustEnergy(player, delta)
    local session = sessions[player]
    if not session then
        return 0
    end

    session.Data.Energy = math.max(0, session.Data.Energy + delta)
    if delta > 0 then
        session.Data.TotalEnergy = session.Data.TotalEnergy + delta
    end
    return session.Data.Energy
end

function SessionService.SetInventory(player, amount)
    local session = sessions[player]
    if not session then
        return 0
    end
    session.Inventory = math.max(0, amount)
    return session.Inventory
end

function SessionService.AddInventory(player, delta)
    local session = sessions[player]
    if not session then
        return 0
    end
    session.Inventory = math.max(0, session.Inventory + delta)
    return session.Inventory
end

function SessionService.RecordZoneUnlock(player, zoneLevel)
    local session = sessions[player]
    if not session then
        return
    end
    session.Data.ZoneLevel = math.max(session.Data.ZoneLevel, zoneLevel)
end

function SessionService.RecordUpgrade(player, upgradeType, newLevel)
    local session = sessions[player]
    if not session then
        return
    end
    local key = upgradeType .. "Level"
    if session.Data[key] ~= nil then
        session.Data[key] = newLevel
    end
end

function SessionService.RecordRebirth(player)
    local session = sessions[player]
    if not session then
        return
    end
    session.Data.Rebirths += 1
    session.Data.Energy = Config.Rebirth.BonusEnergy
    session.Data.TotalEnergy = session.Data.TotalEnergy + Config.Rebirth.BonusEnergy
    session.Data.CapacityLevel = 1
    session.Data.SpeedLevel = 1
    session.Data.ConverterLevel = 1
    session.Data.ZoneLevel = 1
    session.Inventory = 0
    ensureSettings(session)
    local combo = ensureCombo(session)
    combo.Count = 0
    combo.Expires = 0
end

function SessionService.AddBoost(player, key, data)
    local session = sessions[player]
    if not session then
        return
    end
    session.Boosts[key] = data
end

function SessionService.RegisterComboHit(player)
    local session = sessions[player]
    if not session then
        return 0
    end

    local combo = ensureCombo(session)
    local now = os.clock()
    local window = (Config.Combo and Config.Combo.Window) or 4

    if now <= (combo.Expires or 0) then
        combo.Count += 1
    else
        combo.Count = 1
    end

    combo.Expires = now + window
    combo.Best = math.max(combo.Best or 0, combo.Count)

    return combo.Count
end

function SessionService.ResetCombo(player)
    local session = sessions[player]
    if not session then
        return
    end

    local combo = ensureCombo(session)
    combo.Count = 0
    combo.Expires = 0
end

function SessionService.GetComboInfo(player)
    local session = sessions[player]
    if not session then
        return { Count = 0, Multiplier = 1, Remaining = 0, Best = 0 }
    end

    local combo = ensureCombo(session)
    local now = os.clock()
    if now > (combo.Expires or 0) then
        combo.Count = 0
    end

    local perHit = (Config.Combo and Config.Combo.BonusPerStreak) or 0
    local maxBonus = (Config.Combo and Config.Combo.MaxBonus) or 0
    local bonus = math.clamp((combo.Count - 1) * perHit, 0, maxBonus)
    local remaining = math.max(0, (combo.Expires or 0) - now)

    return {
        Count = combo.Count,
        Multiplier = 1 + bonus,
        Remaining = remaining,
        Best = combo.Best or combo.Count
    }
end

function SessionService.GetSettings(player)
    local session = sessions[player]
    if not session then
        return {}
    end
    ensureSettings(session)
    return session.Data.Settings
end

function SessionService.GetSetting(player, key)
    local settings = SessionService.GetSettings(player)
    return settings[key]
end

function SessionService.SetSetting(player, key, value)
    local session = sessions[player]
    if not session then
        return
    end

    ensureSettings(session)
    session.Data.Settings[key] = value
end

function SessionService.GetBoosts(player)
    local session = sessions[player]
    if not session then
        return {}
    end
    return session.Boosts
end

function SessionService.ClearBoost(player, key)
    local session = sessions[player]
    if not session then
        return
    end
    session.Boosts[key] = nil
end

function SessionService.GetAllSessions()
    return sessions
end

function SessionService.SaveAll()
    for player in pairs(sessions) do
        SessionService.SaveSession(player)
    end
end

Players.PlayerRemoving:Connect(function(player)
    SessionService.SaveSession(player)
    SessionService.RemoveSession(player)
end)

game:BindToClose(function()
    SessionService.SaveAll()
end)

return SessionService
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="13">
        <Properties>
          <string name="Name">UpgradeService</string>
          <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local Config = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Config"))
local SessionService = require(script.Parent:WaitForChild("SessionService"))

local UpgradeService = {}

UpgradeService.Monetization = nil
UpgradeService.Remotes = nil

local function getSession(player)
    return SessionService.GetSession(player)
end

local function applyWalkSpeed(player)
    local session = getSession(player)
    if not session then
        return
    end

    local character = player.Character
    if not character then
        return
    end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then
        return
    end

    humanoid.WalkSpeed = UpgradeService.GetWalkSpeed(player)
end

local function cleanBoosts(session)
    local now = os.time()
    for key, data in pairs(session.Boosts) do
        if data.Expires and data.Expires <= now then
            session.Boosts[key] = nil
        end
    end
end

function UpgradeService.SetDependencies(remotes, monetization)
    UpgradeService.Remotes = remotes
    UpgradeService.Monetization = monetization
end

function UpgradeService.GetCapacity(player)
    local session = getSession(player)
    if not session then
        return 0
    end

    local level = session.Data.CapacityLevel
    local stats = Config.getUpgradeStats("Capacity", level)
    local capacity = stats and stats.Capacity or 0

    if UpgradeService.Monetization and UpgradeService.Monetization.PlayerHasPass(player, "INFINITE_STORAGE") then
        capacity = math.huge
    end

    return capacity
end

function UpgradeService.GetWalkSpeed(player)
    local session = getSession(player)
    if not session then
        return Config.BaseWalkSpeed
    end

    local stats = Config.getUpgradeStats("Speed", session.Data.SpeedLevel)
    local speed = stats and stats.WalkSpeed or Config.BaseWalkSpeed

    if UpgradeService.Monetization and UpgradeService.Monetization.PlayerHasPass(player, "HYPER_SPRINT") then
        local enabled = SessionService.GetSetting(player, "HyperSprint")
        if enabled then
            speed *= Config.Gamepasses.HYPER_SPRINT.SpeedMultiplier
        end
    end

    return speed
end

function UpgradeService.GetConverterMultiplier(player)
    local session = getSession(player)
    if not session then
        return 1
    end

    cleanBoosts(session)

    local stats = Config.getUpgradeStats("Converter", session.Data.ConverterLevel)
    local multiplier = stats and stats.Multiplier or 1

    local boosts = SessionService.GetBoosts(player)
    for key, data in pairs(boosts) do
        if data.Multiplier then
            multiplier *= data.Multiplier
        end
    end

    multiplier *= Config.getRebirthMultiplier(session.Data.Rebirths)

    return multiplier
end

function UpgradeService.GetStateSummary(player)
    local session = getSession(player)
    if not session then
        return nil
    end

    cleanBoosts(session)

    local summary = {
        Energy = session.Data.Energy,
        TotalEnergy = session.Data.TotalEnergy,
        Inventory = session.Inventory,
        Capacity = UpgradeService.GetCapacity(player),
        CapacityLevel = session.Data.CapacityLevel,
        CapacityNextCost = Config.getNextUpgradeCost("Capacity", session.Data.CapacityLevel),
        Speed = UpgradeService.GetWalkSpeed(player),
        SpeedLevel = session.Data.SpeedLevel,
        SpeedNextCost = Config.getNextUpgradeCost("Speed", session.Data.SpeedLevel),
        ConverterLevel = session.Data.ConverterLevel,
        ConverterMultiplier = UpgradeService.GetConverterMultiplier(player),
        ConverterNextCost = Config.getNextUpgradeCost("Converter", session.Data.ConverterLevel),
        ZoneLevel = session.Data.ZoneLevel,
        NextZoneCost = Config.getZoneUnlockCost(session.Data.ZoneLevel + 1),
        Rebirths = session.Data.Rebirths,
        RebirthCost = Config.getRebirthCost(session.Data.Rebirths)
    }

    if summary.Capacity == math.huge then
        summary.CapacityDisplay = "Infinite"
    else
        summary.CapacityDisplay = tostring(summary.Capacity)
    end

    if UpgradeService.Monetization then
        summary.Gamepasses = {}
        for key, value in pairs(UpgradeService.Monetization.GetOwnedPasses(player)) do
            if value then
                summary.Gamepasses[key] = true
            end
        end
    end

    summary.Settings = SessionService.GetSettings(player)

    local boosts = SessionService.GetBoosts(player)
    local boostSummary = {}
    local now = os.time()
    for key, data in pairs(boosts) do
        boostSummary[key] = {
            Multiplier = data.Multiplier,
            ExpiresIn = data.Expires and math.max(0, data.Expires - now) or nil
        }
    end
    summary.ActiveBoosts = boostSummary

    summary.Combo = SessionService.GetComboInfo(player)
    summary.ServerTime = Workspace:GetServerTimeNow()

    return summary
end

function UpgradeService.HandleUpgrade(player, upgradeType)
    local session = getSession(player)
    if not session then
        return false, "No session"
    end

    local path = Config.getUpgradePath(upgradeType)
    if not path then
        return false, "Invalid upgrade"
    end

    local currentLevel = session.Data[upgradeType .. "Level"]
    local nextTier = path[currentLevel + 1]
    if not nextTier then
        return false, "Maxed"
    end

    local cost = nextTier.Cost
    if session.Data.Energy < cost then
        return false, string.format("Need %d Energy", cost)
    end

    SessionService.AdjustEnergy(player, -cost)
    SessionService.RecordUpgrade(player, upgradeType, currentLevel + 1)

    if upgradeType == "Speed" then
        task.defer(applyWalkSpeed, player)
    end

    return true, string.format("%s upgraded to level %d", upgradeType, currentLevel + 1)
end

function UpgradeService.HandleZoneUnlock(player)
    local session = getSession(player)
    if not session then
        return false, "No session"
    end

    local nextIndex = session.Data.ZoneLevel + 1
    local zone = Config.getZone(nextIndex)
    if not zone then
        return false, "No more zones"
    end

    local cost = zone.UnlockCost
    if session.Data.Energy < cost then
        return false, string.format("Need %d Energy", cost)
    end

    SessionService.AdjustEnergy(player, -cost)
    SessionService.RecordZoneUnlock(player, nextIndex)

    return true, string.format("Unlocked %s", zone.Name)
end

function UpgradeService.HandleRebirth(player)
    local session = getSession(player)
    if not session then
        return false, "No session"
    end

    if session.Data.ZoneLevel < #Config.Zones then
        return false, "Unlock all zones first"
    end

    local cost = Config.getRebirthCost(session.Data.Rebirths)
    if session.Data.Energy < cost then
        return false, string.format("Need %d Energy", cost)
    end

    SessionService.AdjustEnergy(player, -cost)
    SessionService.RecordRebirth(player)

    task.defer(applyWalkSpeed, player)

    return true, "Rebirth complete!"
end

function UpgradeService.ApplyCharacterScaling(player)
    task.defer(applyWalkSpeed, player)
end

function UpgradeService.CanUseHyperSprint(player)
    if not UpgradeService.Monetization then
        return false
    end
    return UpgradeService.Monetization.PlayerHasPass(player, "HYPER_SPRINT")
end

function UpgradeService.CanUseAutoCollector(player)
    if not UpgradeService.Monetization then
        return false
    end
    return UpgradeService.Monetization.PlayerHasPass(player, "AUTO_COLLECTOR")
end

return UpgradeService
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="14">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="Folder" referent="15">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="16">
        <Properties>
          <string name="Name">ClientController</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local Config = require(ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Config"))

local remotesFolder = ReplicatedStorage:WaitForChild("Remotes")
local eventsFolder = remotesFolder:WaitForChild("Events")

local remotes = {
    StateUpdate = eventsFolder:WaitForChild("StateUpdate"),
    Notify = eventsFolder:WaitForChild("Notify"),
    ActionRequest = eventsFolder:WaitForChild("ActionRequest"),
    PurchaseRequest = eventsFolder:WaitForChild("PurchaseRequest"),
    Tutorial = eventsFolder:WaitForChild("Tutorial")
}

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CrystalRushUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

local fontMain = Enum.Font.Gotham
local fontBold = Enum.Font.GothamBold

local milestoneTargets = { 500, 2000, 7500, 22000, 64000, 185000, 520000, 1250000 }
local comboMaxCount = math.max(
    5,
    math.floor(
        ((Config.Combo and Config.Combo.MaxBonus) or 0.4)
            / math.max(((Config.Combo and Config.Combo.BonusPerStreak) or 0.04), 0.01)
    ) + 1
)

local function createShadow(frame)
    local shadow = Instance.new("ImageLabel")
    shadow.Name = "Shadow"
    shadow.Image = "rbxassetid://1316045217"
    shadow.ImageTransparency = 0.6
    shadow.BackgroundTransparency = 1
    shadow.Size = UDim2.new(1, 12, 1, 12)
    shadow.Position = UDim2.new(0, -6, 0, -6)
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(10, 10, 118, 118)
    shadow.ZIndex = frame.ZIndex - 1
    shadow.Parent = frame
end

local function applyCorner(frame, radius)
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, radius or 12)
    corner.Parent = frame
    return corner
end

local function applyStroke(frame, color, thickness)
    local stroke = Instance.new("UIStroke")
    stroke.Thickness = thickness or 1.2
    stroke.Color = color or Color3.fromRGB(52, 82, 146)
    stroke.Transparency = 0.1
    stroke.Parent = frame
    return stroke
end

local function applyGradient(frame, color1, color2)
    local gradient = Instance.new("UIGradient")
    gradient.Color = ColorSequence.new(color1, color2 or color1)
    gradient.Rotation = 90
    gradient.Parent = frame
    return gradient
end

local function updateGradient(frame, color1, color2)
    local gradient = frame:FindFirstChildOfClass("UIGradient")
    if gradient then
        gradient.Color = ColorSequence.new(color1, color2 or color1)
    end
    frame.BackgroundColor3 = color1
end

local function updateStroke(frame, color)
    local stroke = frame:FindFirstChildOfClass("UIStroke")
    if stroke then
        stroke.Color = color
    end
end

local function createLabel(parent, text, size, position, bold)
    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.Text = text
    label.Font = bold and fontBold or fontMain
    label.TextColor3 = Color3.fromRGB(240, 244, 255)
    label.TextScaled = true
    label.Size = size
    label.Position = position
    label.Parent = parent
    return label
end

local hudPanel = Instance.new("Frame")
hudPanel.Name = "StatsPanel"
hudPanel.Size = UDim2.new(0, 340, 0, 240)
hudPanel.Position = UDim2.new(0, 24, 0, 24)
hudPanel.BackgroundColor3 = Color3.fromRGB(24, 32, 58)
hudPanel.BorderSizePixel = 0
hudPanel.ZIndex = 3
hudPanel.Parent = screenGui
applyCorner(hudPanel, 18)
applyStroke(hudPanel, Color3.fromRGB(58, 86, 144), 1.8)
applyGradient(hudPanel, Color3.fromRGB(32, 46, 82), Color3.fromRGB(18, 24, 42))

local hudPadding = Instance.new("UIPadding")
hudPadding.PaddingLeft = UDim.new(0, 18)
hudPadding.PaddingRight = UDim.new(0, 18)
hudPadding.PaddingTop = UDim.new(0, 16)
hudPadding.PaddingBottom = UDim.new(0, 14)
hudPadding.Parent = hudPanel

local hudLayout = Instance.new("UIListLayout")
hudLayout.Parent = hudPanel
hudLayout.FillDirection = Enum.FillDirection.Vertical
hudLayout.Padding = UDim.new(0, 10)
hudLayout.SortOrder = Enum.SortOrder.LayoutOrder

local energyHeader = Instance.new("Frame")
energyHeader.BackgroundTransparency = 1
energyHeader.Size = UDim2.new(1, 0, 0, 64)
energyHeader.LayoutOrder = 1
energyHeader.Parent = hudPanel

local energyIcon = Instance.new("ImageLabel")
energyIcon.BackgroundTransparency = 1
energyIcon.Image = "rbxassetid://6034509990"
energyIcon.ImageColor3 = Color3.fromRGB(255, 228, 125)
energyIcon.Size = UDim2.new(0, 40, 0, 40)
energyIcon.Position = UDim2.new(0, 0, 0, 10)
energyIcon.Parent = energyHeader

local energyLabel = createLabel(energyHeader, "0", UDim2.new(0, 180, 0, 40), UDim2.new(0, 48, 0, 4), true)
energyLabel.TextXAlignment = Enum.TextXAlignment.Left

local energyCaption = createLabel(energyHeader, "Energy", UDim2.new(0, 140, 0, 24), UDim2.new(0, 48, 0, 40), false)
energyCaption.TextXAlignment = Enum.TextXAlignment.Left
energyCaption.TextColor3 = Color3.fromRGB(198, 215, 255)

local vipStatusLabel = createLabel(energyHeader, "Adventurer", UDim2.new(0, 130, 0, 24), UDim2.new(1, -140, 0, 12), true)
vipStatusLabel.AnchorPoint = Vector2.new(0, 0)
vipStatusLabel.TextScaled = true
vipStatusLabel.TextXAlignment = Enum.TextXAlignment.Right
vipStatusLabel.TextColor3 = Color3.fromRGB(255, 229, 115)

local inventoryContainer = Instance.new("Frame")
inventoryContainer.Size = UDim2.new(1, 0, 0, 46)
inventoryContainer.BackgroundColor3 = Color3.fromRGB(18, 26, 46)
inventoryContainer.BorderSizePixel = 0
inventoryContainer.LayoutOrder = 2
inventoryContainer.Parent = hudPanel
applyCorner(inventoryContainer, 12)
applyStroke(inventoryContainer, Color3.fromRGB(48, 72, 132), 1.4)

local inventoryFill = Instance.new("Frame")
inventoryFill.BackgroundColor3 = Color3.fromRGB(116, 206, 255)
inventoryFill.Size = UDim2.new(0, 0, 1, 0)
inventoryFill.BorderSizePixel = 0
inventoryFill.Parent = inventoryContainer
inventoryFill.Visible = false
applyCorner(inventoryFill, 12)
applyGradient(inventoryFill, Color3.fromRGB(104, 209, 240), Color3.fromRGB(80, 156, 255))

local inventoryLabel = createLabel(inventoryContainer, "Backpack 0 / 0", UDim2.new(1, -16, 1, -8), UDim2.new(0, 8, 0, 4), false)
inventoryLabel.TextXAlignment = Enum.TextXAlignment.Left

local comboContainer = Instance.new("Frame")
comboContainer.Size = UDim2.new(1, 0, 0, 42)
comboContainer.BackgroundColor3 = Color3.fromRGB(18, 28, 50)
comboContainer.BorderSizePixel = 0
comboContainer.LayoutOrder = 3
comboContainer.Parent = hudPanel
applyCorner(comboContainer, 12)
applyStroke(comboContainer, Color3.fromRGB(66, 98, 168), 1.2)

local comboFill = Instance.new("Frame")
comboFill.Size = UDim2.new(0, 0, 1, 0)
comboFill.BackgroundColor3 = Color3.fromRGB(180, 132, 255)
comboFill.BorderSizePixel = 0
comboFill.Parent = comboContainer
comboFill.Visible = false
applyCorner(comboFill, 12)
applyGradient(comboFill, Color3.fromRGB(210, 144, 255), Color3.fromRGB(128, 92, 255))

local comboLabel = createLabel(comboContainer, "Combo x1", UDim2.new(0.5, -10, 1, -8), UDim2.new(0, 10, 0, 4), true)
comboLabel.TextXAlignment = Enum.TextXAlignment.Left

local comboTimerLabel = createLabel(comboContainer, "Ready", UDim2.new(0.5, -10, 1, -8), UDim2.new(0.5, 10, 0, 4), false)
comboTimerLabel.TextXAlignment = Enum.TextXAlignment.Right
comboTimerLabel.TextColor3 = Color3.fromRGB(206, 214, 255)

local statRow = Instance.new("Frame")
statRow.BackgroundTransparency = 1
statRow.Size = UDim2.new(1, 0, 0, 36)
statRow.LayoutOrder = 4
statRow.Parent = hudPanel

local statLayout = Instance.new("UIListLayout")
statLayout.Parent = statRow
statLayout.FillDirection = Enum.FillDirection.Horizontal
statLayout.Padding = UDim.new(0, 8)
statLayout.SortOrder = Enum.SortOrder.LayoutOrder

local function createStatPill(text)
    local pill = Instance.new("Frame")
    pill.Size = UDim2.new(0, 104, 1, 0)
    pill.BackgroundColor3 = Color3.fromRGB(28, 36, 64)
    pill.BorderSizePixel = 0
    applyCorner(pill, 10)
    applyStroke(pill, Color3.fromRGB(58, 86, 144), 1)

    local label = createLabel(pill, text, UDim2.new(1, -12, 1, -8), UDim2.new(0, 6, 0, 4), false)
    label.TextXAlignment = Enum.TextXAlignment.Left
    return pill, label
end

local zonePill, zoneLabel = createStatPill("Zone 1")
zonePill.Parent = statRow

local rebirthPill, rebirthLabel = createStatPill("Rebirth 0")
rebirthPill.Parent = statRow

local multiplierPill, multiplierLabel = createStatPill("x1.00")
multiplierPill.Parent = statRow

local boostLabel = createLabel(hudPanel, "Boosts: None", UDim2.new(1, 0, 0, 26), UDim2.new(0, 0, 0, 0), false)
boostLabel.LayoutOrder = 5
boostLabel.TextXAlignment = Enum.TextXAlignment.Left
boostLabel.TextWrapped = true

local abilityDock = Instance.new("Frame")
abilityDock.Name = "AbilityDock"
abilityDock.Size = UDim2.new(0, 360, 0, 64)
abilityDock.Position = UDim2.new(0.5, -180, 1, -120)
abilityDock.BackgroundColor3 = Color3.fromRGB(22, 30, 54)
abilityDock.BorderSizePixel = 0
abilityDock.ZIndex = 3
abilityDock.Parent = screenGui
applyCorner(abilityDock, 18)
applyStroke(abilityDock, Color3.fromRGB(56, 86, 144), 1.8)
applyGradient(abilityDock, Color3.fromRGB(28, 42, 78), Color3.fromRGB(16, 20, 36))

local abilityLayout = Instance.new("UIListLayout")
abilityLayout.Parent = abilityDock
abilityLayout.FillDirection = Enum.FillDirection.Horizontal
abilityLayout.Padding = UDim.new(0, 12)
abilityLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
abilityLayout.VerticalAlignment = Enum.VerticalAlignment.Center

local function createAbilityButton(name, text)
    local button = Instance.new("TextButton")
    button.Name = name
    button.Size = UDim2.new(0.5, -12, 0, 48)
    button.BackgroundColor3 = Color3.fromRGB(64, 86, 150)
    button.BorderSizePixel = 0
    button.AutoButtonColor = true
    button.Font = fontBold
    button.TextScaled = true
    button.Text = text
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.Parent = abilityDock
    applyCorner(button, 14)
    applyStroke(button, Color3.fromRGB(82, 120, 192), 1)
    return button
end

local sprintToggleButton = createAbilityButton("SprintToggle", "Hyper Sprint")
local autoToggleButton = createAbilityButton("AutoToggle", "Auto Collector")

local upgradesPanel = Instance.new("Frame")
upgradesPanel.Name = "UpgradesPanel"
upgradesPanel.Size = UDim2.new(0, 340, 0, 320)
upgradesPanel.Position = UDim2.new(0, 24, 0, 284)
upgradesPanel.BackgroundColor3 = Color3.fromRGB(22, 30, 56)
upgradesPanel.BorderSizePixel = 0
upgradesPanel.ZIndex = 3
upgradesPanel.Parent = screenGui
applyCorner(upgradesPanel, 18)
applyStroke(upgradesPanel, Color3.fromRGB(56, 86, 144), 1.6)
applyGradient(upgradesPanel, Color3.fromRGB(28, 42, 78), Color3.fromRGB(16, 20, 36))

local upgradesPadding = Instance.new("UIPadding")
upgradesPadding.PaddingLeft = UDim.new(0, 18)
upgradesPadding.PaddingRight = UDim.new(0, 18)
upgradesPadding.PaddingTop = UDim.new(0, 22)
upgradesPadding.PaddingBottom = UDim.new(0, 18)
upgradesPadding.Parent = upgradesPanel

local upgradesLayout = Instance.new("UIListLayout")
upgradesLayout.Parent = upgradesPanel
upgradesLayout.Padding = UDim.new(0, 8)
upgradesLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
upgradesLayout.VerticalAlignment = Enum.VerticalAlignment.Top
upgradesLayout.SortOrder = Enum.SortOrder.LayoutOrder

local function createActionButton(parent, text, action)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, -20, 0, 48)
    button.Text = text
    button.Font = fontBold
    button.TextScaled = true
    button.BackgroundColor3 = Color3.fromRGB(68, 108, 204)
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.BorderSizePixel = 0
    button.AutoButtonColor = true
    button.Parent = parent
    button.LayoutOrder = #parent:GetChildren()
    applyCorner(button, 14)
    applyStroke(button, Color3.fromRGB(94, 140, 255), 1.2)
    applyGradient(button, Color3.fromRGB(92, 148, 255), Color3.fromRGB(60, 94, 198))
    button.TextWrapped = true

    button.MouseButton1Click:Connect(function()
        remotes.ActionRequest:FireServer(action)
    end)

    return button
end

local buttons = {
    Capacity = createActionButton(upgradesPanel, "Upgrade Backpack", "UpgradeCapacity"),
    Speed = createActionButton(upgradesPanel, "Upgrade Speed", "UpgradeSpeed"),
    Converter = createActionButton(upgradesPanel, "Upgrade Converter", "UpgradeConverter"),
    UnlockZone = createActionButton(upgradesPanel, "Unlock Next Zone", "UnlockZone"),
    Rebirth = createActionButton(upgradesPanel, "Rebirth", "Rebirth")
}

local shopToggle = Instance.new("TextButton")
shopToggle.Name = "ShopToggle"
shopToggle.Size = UDim2.new(0, 220, 0, 50)
shopToggle.Position = UDim2.new(1, -24, 0, 24)
shopToggle.AnchorPoint = Vector2.new(1, 0)
shopToggle.BackgroundColor3 = Color3.fromRGB(32, 44, 82)
shopToggle.Text = "Open Crystal Shop"
shopToggle.TextScaled = true
shopToggle.Font = fontBold
shopToggle.TextColor3 = Color3.fromRGB(255, 255, 255)
shopToggle.Parent = screenGui
applyCorner(shopToggle, 16)
applyStroke(shopToggle, Color3.fromRGB(86, 132, 228), 1.4)
applyGradient(shopToggle, Color3.fromRGB(72, 110, 210), Color3.fromRGB(44, 62, 120))

local shopFrame = Instance.new("Frame")
shopFrame.Name = "ShopFrame"
shopFrame.Size = UDim2.new(0, 440, 0, 440)
shopFrame.Position = UDim2.new(1, -24, 0, 96)
shopFrame.AnchorPoint = Vector2.new(1, 0)
shopFrame.BackgroundColor3 = Color3.fromRGB(18, 22, 38)
shopFrame.BorderSizePixel = 0
shopFrame.Visible = false
shopFrame.ZIndex = 5
shopFrame.Parent = screenGui
applyCorner(shopFrame, 18)
applyStroke(shopFrame, Color3.fromRGB(60, 92, 160), 1.6)
applyGradient(shopFrame, Color3.fromRGB(32, 46, 82), Color3.fromRGB(18, 22, 36))

local shopPadding = Instance.new("UIPadding")
shopPadding.PaddingLeft = UDim.new(0, 18)
shopPadding.PaddingRight = UDim.new(0, 18)
shopPadding.PaddingTop = UDim.new(0, 18)
shopPadding.PaddingBottom = UDim.new(0, 18)
shopPadding.Parent = shopFrame

local shopClose = Instance.new("TextButton")
shopClose.Size = UDim2.new(0, 28, 0, 28)
shopClose.Position = UDim2.new(1, -36, 0, 10)
shopClose.BackgroundTransparency = 1
shopClose.Text = "✕"
shopClose.Font = fontBold
shopClose.TextColor3 = Color3.fromRGB(255, 255, 255)
shopClose.Parent = shopFrame

local shopTitle = createLabel(shopFrame, "Crystal Shop", UDim2.new(1, -20, 0, 32), UDim2.new(0, 10, 0, 10), true)
shopTitle.TextXAlignment = Enum.TextXAlignment.Left

local shopScroll = Instance.new("ScrollingFrame")
shopScroll.Size = UDim2.new(1, -20, 1, -60)
shopScroll.Position = UDim2.new(0, 10, 0, 50)
shopScroll.BackgroundTransparency = 1
shopScroll.BorderSizePixel = 0
shopScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
shopScroll.ScrollBarThickness = 6
shopScroll.Parent = shopFrame

local shopLayout = Instance.new("UIListLayout")
shopLayout.Parent = shopScroll
shopLayout.Padding = UDim.new(0, 10)
shopLayout.SortOrder = Enum.SortOrder.LayoutOrder

local eventBanner = Instance.new("Frame")
eventBanner.Name = "EventBanner"
eventBanner.Size = UDim2.new(0, 440, 0, 68)
eventBanner.Position = UDim2.new(0.5, -220, 0, 20)
eventBanner.AnchorPoint = Vector2.new(0.5, 0)
eventBanner.BackgroundColor3 = Color3.fromRGB(22, 30, 58)
eventBanner.Visible = false
eventBanner.ZIndex = 6
eventBanner.Parent = screenGui
applyCorner(eventBanner, 18)
applyStroke(eventBanner, Color3.fromRGB(86, 132, 228), 1.6)
applyGradient(eventBanner, Color3.fromRGB(44, 62, 120), Color3.fromRGB(28, 36, 70))

local eventPadding = Instance.new("UIPadding")
eventPadding.PaddingLeft = UDim.new(0, 18)
eventPadding.PaddingRight = UDim.new(0, 18)
eventPadding.PaddingTop = UDim.new(0, 12)
eventPadding.PaddingBottom = UDim.new(0, 12)
eventPadding.Parent = eventBanner

local eventNameLabel = createLabel(eventBanner, "", UDim2.new(0.6, 0, 0, 24), UDim2.new(0, 0, 0, 0), true)
eventNameLabel.TextXAlignment = Enum.TextXAlignment.Left

local eventZoneLabel = createLabel(eventBanner, "", UDim2.new(0.6, 0, 0, 20), UDim2.new(0, 0, 0, 28), false)
eventZoneLabel.TextXAlignment = Enum.TextXAlignment.Left
eventZoneLabel.TextColor3 = Color3.fromRGB(198, 215, 255)

local eventTimerLabel = createLabel(eventBanner, "", UDim2.new(0.4, 0, 0, 24), UDim2.new(1, -160, 0, 0), true)
eventTimerLabel.AnchorPoint = Vector2.new(0, 0)
eventTimerLabel.TextXAlignment = Enum.TextXAlignment.Right

local eventDescriptionLabel = createLabel(eventBanner, "", UDim2.new(0.4, 0, 0, 20), UDim2.new(1, -160, 0, 28), false)
eventDescriptionLabel.AnchorPoint = Vector2.new(0, 0)
eventDescriptionLabel.TextXAlignment = Enum.TextXAlignment.Right
eventDescriptionLabel.TextColor3 = Color3.fromRGB(206, 214, 255)

local eventProgress = Instance.new("Frame")
eventProgress.Size = UDim2.new(1, -20, 0, 6)
eventProgress.Position = UDim2.new(0, 10, 1, -14)
eventProgress.BackgroundColor3 = Color3.fromRGB(18, 24, 42)
eventProgress.BorderSizePixel = 0
eventProgress.Parent = eventBanner
applyCorner(eventProgress, 6)

local eventProgressFill = Instance.new("Frame")
eventProgressFill.Size = UDim2.new(0, 0, 1, 0)
eventProgressFill.BackgroundColor3 = Color3.fromRGB(120, 196, 255)
eventProgressFill.BorderSizePixel = 0
eventProgressFill.Parent = eventProgress
eventProgressFill.Visible = false
applyCorner(eventProgressFill, 6)

local zoneTrack = Instance.new("Frame")
zoneTrack.Name = "ZoneTrack"
zoneTrack.Size = UDim2.new(0, 340, 0, 60)
zoneTrack.Position = UDim2.new(0, 24, 1, -96)
zoneTrack.BackgroundColor3 = Color3.fromRGB(20, 28, 52)
zoneTrack.BorderSizePixel = 0
zoneTrack.ZIndex = 3
zoneTrack.Parent = screenGui
applyCorner(zoneTrack, 16)
applyStroke(zoneTrack, Color3.fromRGB(52, 82, 146), 1.2)

local zoneTrackPadding = Instance.new("UIPadding")
zoneTrackPadding.PaddingLeft = UDim.new(0, 16)
zoneTrackPadding.PaddingRight = UDim.new(0, 16)
zoneTrackPadding.PaddingTop = UDim.new(0, 12)
zoneTrackPadding.PaddingBottom = UDim.new(0, 12)
zoneTrackPadding.Parent = zoneTrack

local zoneTrackLayout = Instance.new("UIListLayout")
zoneTrackLayout.Parent = zoneTrack
zoneTrackLayout.FillDirection = Enum.FillDirection.Horizontal
zoneTrackLayout.Padding = UDim.new(0, 10)
zoneTrackLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
zoneTrackLayout.VerticalAlignment = Enum.VerticalAlignment.Center

local zoneNodes = {}
for index, zoneConfig in ipairs(Config.Zones) do
    local node = Instance.new("Frame")
    node.Name = "ZoneNode" .. index
    node.Size = UDim2.new(0, 30, 0, 30)
    node.BackgroundColor3 = Color3.fromRGB(46, 58, 92)
    node.BorderSizePixel = 0
    node.Parent = zoneTrack
    applyCorner(node, 15)
    applyStroke(node, zoneConfig.AccentColor or zoneConfig.OrbColor, 1)

    local nodeLabel = createLabel(node, tostring(index), UDim2.new(1, -4, 1, -4), UDim2.new(0, 2, 0, 2), true)
    nodeLabel.TextXAlignment = Enum.TextXAlignment.Center
    nodeLabel.TextYAlignment = Enum.TextYAlignment.Center

    zoneNodes[index] = { Frame = node, Label = nodeLabel }
end

local milestoneCard = Instance.new("Frame")
milestoneCard.Name = "MilestoneCard"
milestoneCard.Size = UDim2.new(0, 220, 0, 120)
milestoneCard.Position = UDim2.new(1, -24, 0, 96)
milestoneCard.AnchorPoint = Vector2.new(1, 0)
milestoneCard.BackgroundColor3 = Color3.fromRGB(24, 34, 60)
milestoneCard.BorderSizePixel = 0
milestoneCard.ZIndex = 4
milestoneCard.Parent = screenGui
applyCorner(milestoneCard, 16)
applyStroke(milestoneCard, Color3.fromRGB(70, 108, 200), 1.2)
applyGradient(milestoneCard, Color3.fromRGB(32, 46, 82), Color3.fromRGB(20, 28, 50))

local milestonePadding = Instance.new("UIPadding")
milestonePadding.PaddingLeft = UDim.new(0, 14)
milestonePadding.PaddingRight = UDim.new(0, 14)
milestonePadding.PaddingTop = UDim.new(0, 14)
milestonePadding.PaddingBottom = UDim.new(0, 14)
milestonePadding.Parent = milestoneCard

local milestoneTitle = createLabel(milestoneCard, "Next Goal", UDim2.new(1, 0, 0, 24), UDim2.new(0, 0, 0, 0), true)
milestoneTitle.TextXAlignment = Enum.TextXAlignment.Left

local milestoneValueLabel = createLabel(milestoneCard, "", UDim2.new(1, 0, 0, 32), UDim2.new(0, 0, 0, 30), true)
milestoneValueLabel.TextXAlignment = Enum.TextXAlignment.Left
milestoneValueLabel.TextColor3 = Color3.fromRGB(120, 196, 255)

local milestoneHintLabel = createLabel(milestoneCard, "", UDim2.new(1, 0, 0, 24), UDim2.new(0, 0, 0, 66), false)
milestoneHintLabel.TextXAlignment = Enum.TextXAlignment.Left
milestoneHintLabel.TextColor3 = Color3.fromRGB(206, 214, 255)

local notificationFrame = Instance.new("Frame")
notificationFrame.Name = "Notification"
notificationFrame.Size = UDim2.new(0, 420, 0, 36)
notificationFrame.Position = UDim2.new(0.5, -210, 0, 24)
notificationFrame.BackgroundColor3 = Color3.fromRGB(47, 60, 102)
notificationFrame.BackgroundTransparency = 0.2
notificationFrame.Visible = false
notificationFrame.ZIndex = 10
notificationFrame.Parent = screenGui
createShadow(notificationFrame)

local notificationLabel = createLabel(notificationFrame, "", UDim2.new(1, -20, 1, 0), UDim2.new(0, 10, 0, 0), true)
notificationLabel.TextXAlignment = Enum.TextXAlignment.Left

local tutorialFrame = Instance.new("Frame")
tutorialFrame.Name = "TutorialFrame"
tutorialFrame.Size = UDim2.new(0, 500, 0, 60)
tutorialFrame.Position = UDim2.new(0.5, -250, 1, -140)
tutorialFrame.BackgroundColor3 = Color3.fromRGB(38, 46, 80)
tutorialFrame.Visible = false
tutorialFrame.ZIndex = 8
tutorialFrame.Parent = screenGui
createShadow(tutorialFrame)

local tutorialLabel = createLabel(tutorialFrame, "", UDim2.new(1, -20, 1, -10), UDim2.new(0, 10, 0, 5), false)
tutorialLabel.TextWrapped = true

tutorialLabel.TextColor3 = Color3.fromRGB(255, 255, 255)

local currentState
local serverTimeOffset = 0
local comboExpireTime = 0
local activeEvent

local function formatNumber(num)
    if num >= 1e6 then
        return string.format("%.1fm", num / 1e6)
    elseif num >= 1e3 then
        return string.format("%.1fk", num / 1e3)
    else
        return tostring(num)
    end
end

local function setButtonState(button, enabled, text)
    button.Text = text
    if enabled then
        updateGradient(button, Color3.fromRGB(92, 148, 255), Color3.fromRGB(60, 94, 198))
        updateStroke(button, Color3.fromRGB(94, 140, 255))
        button.AutoButtonColor = true
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
    else
        updateGradient(button, Color3.fromRGB(42, 48, 68), Color3.fromRGB(30, 34, 50))
        updateStroke(button, Color3.fromRGB(64, 76, 108))
        button.AutoButtonColor = false
        button.TextColor3 = Color3.fromRGB(182, 194, 220)
    end
end

local function updateInventoryBarUI(inventoryValue, capacityValue, capacityDisplay)
    local ratio = 0
    if capacityValue and capacityValue ~= math.huge and capacityValue > 0 then
        ratio = math.clamp(inventoryValue / capacityValue, 0, 1)
    end

    inventoryFill.Size = UDim2.new(ratio, 0, 1, 0)
    inventoryFill.Visible = ratio > 0

    local capacityText = capacityDisplay
    if capacityText == "Infinite" or capacityValue == math.huge then
        capacityText = "∞"
    elseif not capacityText then
        capacityText = formatNumber(capacityValue or 0)
    end

    inventoryLabel.Text = string.format("Backpack %s / %s", formatNumber(inventoryValue), capacityText)
end

local function updateZoneTrackUI(zoneLevel)
    for index, node in ipairs(zoneNodes) do
        local unlocked = zoneLevel and index <= zoneLevel
        local frame = node.Frame
        local label = node.Label
        if unlocked then
            frame.BackgroundColor3 = Color3.fromRGB(104, 148, 255)
            updateStroke(frame, (Config.Zones[index].AccentColor or Config.Zones[index].OrbColor))
            label.TextColor3 = Color3.fromRGB(255, 255, 255)
        else
            frame.BackgroundColor3 = Color3.fromRGB(46, 58, 92)
            updateStroke(frame, Color3.fromRGB(64, 76, 108))
            label.TextColor3 = Color3.fromRGB(182, 194, 220)
        end
    end
end

local function updateMilestoneCardUI(totalEnergy)
    local nextTarget
    for _, target in ipairs(milestoneTargets) do
        if totalEnergy < target then
            nextTarget = target
            break
        end
    end

    if nextTarget then
        local remaining = math.max(0, nextTarget - totalEnergy)
        milestoneValueLabel.Text = string.format("%s Energy", formatNumber(nextTarget))
        milestoneHintLabel.Text = string.format("Earn %s more to reach it.", formatNumber(remaining))
    else
        milestoneValueLabel.Text = "Legendary Harvester"
        milestoneHintLabel.Text = "Rebirth for even higher rewards."
    end
end

local function updateComboTimerDisplay(combo)
    if not combo or (combo.Count or 0) <= 1 or comboExpireTime <= 0 then
        comboTimerLabel.Text = "Ready"
        return
    end

    local now = workspace:GetServerTimeNow() + serverTimeOffset
    local remaining = math.max(0, comboExpireTime - now)
    local bonusPercent = math.floor(((combo.Multiplier or 1) - 1) * 100)
    if remaining <= 0 then
        comboExpireTime = 0
        comboTimerLabel.Text = "Ready"
        comboFill.Visible = false
        return
    end
    comboTimerLabel.Text = string.format("+%d%% bonus • %.1fs", bonusPercent, remaining)
end

local function updateComboUI(combo)
    local count = combo and combo.Count or 0
    comboLabel.Text = string.format("Combo x%d", math.max(1, count))
    local ratio = math.clamp(count / comboMaxCount, 0, 1)
    comboFill.Size = UDim2.new(ratio, 0, 1, 0)
    if combo and combo.Remaining and count > 1 then
        comboExpireTime = workspace:GetServerTimeNow() + serverTimeOffset + math.max(0, combo.Remaining)
    else
        comboExpireTime = 0
    end

    comboFill.Visible = ratio > 0 and comboExpireTime > 0
    updateComboTimerDisplay(combo)
end

local function updateEventTimerDisplay()
    if not activeEvent then
        return
    end

    local now = workspace:GetServerTimeNow() + serverTimeOffset
    local totalDuration = math.max(1, (activeEvent.EndsAt or now) - (activeEvent.StartedAt or now))
    local remaining = math.max(0, (activeEvent.EndsAt or now) - now)
    eventTimerLabel.Text = string.format("%.0fs remaining", remaining)
    local progress = math.clamp(1 - (remaining / totalDuration), 0, 1)
    eventProgressFill.Size = UDim2.new(progress, 0, 1, 0)

    if remaining <= 0 then
        activeEvent = nil
        eventBanner.Visible = false
        eventProgressFill.Visible = false
    end
end

local function updateEventUI()
    local summary = currentState and currentState.ActiveEvent or nil
    if not summary then
        activeEvent = nil
        eventBanner.Visible = false
        eventProgressFill.Visible = false
        return
    end

    local now = workspace:GetServerTimeNow() + serverTimeOffset
    if summary.EndsAt and summary.EndsAt <= now then
        activeEvent = nil
        eventBanner.Visible = false
        eventProgressFill.Visible = false
        return
    end

    activeEvent = summary
    eventBanner.Visible = true

    local color = summary.Color or Color3.fromRGB(120, 196, 255)
    updateStroke(eventBanner, color)
    updateGradient(
        eventBanner,
        color:Lerp(Color3.fromRGB(255, 255, 255), 0.15),
        color:Lerp(Color3.fromRGB(16, 22, 40), 0.55)
    )
    updateGradient(eventProgressFill, color, color)
    eventProgressFill.Visible = true

    eventNameLabel.Text = summary.Name or "Crystal Event"
    eventZoneLabel.Text = string.format("Zone: %s", summary.ZoneName or ("#" .. tostring(summary.ZoneIndex or "?")))
    eventDescriptionLabel.Text = summary.Description or "Bonus crystals active."

    updateEventTimerDisplay()
end

local function updateAbilityButtons()
    local passes = currentState and currentState.Gamepasses or {}
    local settings = currentState and currentState.Settings or {}

    local isVip = passes and passes.VIP
    if isVip then
        vipStatusLabel.Text = "Crystal VIP"
        vipStatusLabel.TextColor3 = Color3.fromRGB(255, 229, 115)
    else
        vipStatusLabel.Text = "Adventurer"
        vipStatusLabel.TextColor3 = Color3.fromRGB(194, 206, 255)
    end

    local hasSprint = passes and passes.HYPER_SPRINT
    local sprintEnabled = settings and settings.HyperSprint == true
    if hasSprint then
        if sprintEnabled then
            sprintToggleButton.Text = "Hyper Sprint\n[ON]"
            updateGradient(sprintToggleButton, Color3.fromRGB(96, 210, 168), Color3.fromRGB(60, 150, 118))
            updateStroke(sprintToggleButton, Color3.fromRGB(132, 236, 196))
            sprintToggleButton.TextColor3 = Color3.fromRGB(24, 36, 36)
        else
            sprintToggleButton.Text = "Hyper Sprint\n[OFF]"
            updateGradient(sprintToggleButton, Color3.fromRGB(64, 86, 150), Color3.fromRGB(48, 60, 112))
            updateStroke(sprintToggleButton, Color3.fromRGB(82, 120, 192))
            sprintToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        end
        sprintToggleButton.AutoButtonColor = true
    else
        sprintToggleButton.Text = "Hyper Sprint\nUnlock"
        updateGradient(sprintToggleButton, Color3.fromRGB(38, 42, 62), Color3.fromRGB(24, 26, 40))
        updateStroke(sprintToggleButton, Color3.fromRGB(60, 68, 96))
        sprintToggleButton.TextColor3 = Color3.fromRGB(182, 194, 220)
        sprintToggleButton.AutoButtonColor = true
    end

    local hasAuto = passes and passes.AUTO_COLLECTOR
    local autoEnabled = settings and settings.AutoCollector
    if autoEnabled == nil then
        autoEnabled = true
    end
    if hasAuto then
        if autoEnabled then
            autoToggleButton.Text = "Auto Collector\n[ON]"
            updateGradient(autoToggleButton, Color3.fromRGB(120, 206, 255), Color3.fromRGB(80, 148, 220))
            updateStroke(autoToggleButton, Color3.fromRGB(144, 224, 255))
            autoToggleButton.TextColor3 = Color3.fromRGB(24, 36, 44)
        else
            autoToggleButton.Text = "Auto Collector\n[OFF]"
            updateGradient(autoToggleButton, Color3.fromRGB(64, 86, 150), Color3.fromRGB(48, 60, 112))
            updateStroke(autoToggleButton, Color3.fromRGB(82, 120, 192))
            autoToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        end
        autoToggleButton.AutoButtonColor = true
    else
        autoToggleButton.Text = "Auto Collector\nUnlock"
        updateGradient(autoToggleButton, Color3.fromRGB(38, 42, 62), Color3.fromRGB(24, 26, 40))
        updateStroke(autoToggleButton, Color3.fromRGB(60, 68, 96))
        autoToggleButton.TextColor3 = Color3.fromRGB(182, 194, 220)
        autoToggleButton.AutoButtonColor = true
    end
end

local function rebuildShop()
    shopScroll:ClearAllChildren()
    shopLayout.Parent = shopScroll

    local entryIndex = 0

    local function createEntry(title, subtitle, priceText, purchaseData, owned, customClick, customColor)
        entryIndex += 1
        local entry = Instance.new("Frame")
        entry.Size = UDim2.new(1, -4, 0, 90)
        entry.BackgroundColor3 = Color3.fromRGB(33, 40, 65)
        entry.BorderSizePixel = 0
        entry.LayoutOrder = entryIndex
        entry.Parent = shopScroll
        entry.ZIndex = 6

        local entryTitle = createLabel(entry, title, UDim2.new(1, -20, 0, 28), UDim2.new(0, 10, 0, 8), true)
        entryTitle.TextXAlignment = Enum.TextXAlignment.Left
        entryTitle.ZIndex = 7

        local entrySubtitle = createLabel(entry, subtitle, UDim2.new(1, -20, 0, 22), UDim2.new(0, 10, 0, 38), false)
        entrySubtitle.TextXAlignment = Enum.TextXAlignment.Left
        entrySubtitle.TextColor3 = Color3.fromRGB(194, 206, 255)
        entrySubtitle.ZIndex = 7

        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0, 160, 0, 32)
        button.Position = UDim2.new(1, -170, 1, -42)
        button.AnchorPoint = Vector2.new(0, 0)
        button.BackgroundColor3 = customColor or Color3.fromRGB(76, 151, 255)
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.Font = fontBold
        button.TextScaled = true
        button.Text = priceText
        button.Parent = entry
        button.ZIndex = 7

        if owned then
            button.Text = "Owned"
            button.AutoButtonColor = false
            button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        elseif customClick then
            button.MouseButton1Click:Connect(customClick)
        elseif purchaseData then
            button.MouseButton1Click:Connect(function()
                remotes.PurchaseRequest:FireServer(purchaseData)
            end)
        else
            button.Text = "Coming Soon"
            button.AutoButtonColor = false
            button.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
        end
    end

    local passOrder = {"VIP", "HYPER_SPRINT", "INFINITE_STORAGE", "LUCKY_AURA", "AUTO_COLLECTOR"}
    for _, key in ipairs(passOrder) do
        local info = Config.Gamepasses[key]
        if info then
            local owned = currentState and currentState.Gamepasses and currentState.Gamepasses[key]
            local priceText = owned and "Owned" or string.format("R$ %d", info.Price)
            local subtitle = info.Benefit
            local purchaseData = info.Id ~= 0 and { Type = "Gamepass", Key = key } or nil
            if info.Id == 0 then
                priceText = string.format("Set ID • R$ %d", info.Price)
            end
            createEntry(info.Name, subtitle, priceText, purchaseData, owned)
        end
    end

    for _, product in ipairs(Config.DeveloperProducts.EnergyPacks) do
        local priceText = string.format("R$ %d", product.Price)
        local subtitle = string.format("+%s Energy", formatNumber(product.Amount))
        local purchaseData = product.Id ~= 0 and { Type = "Product", Key = product.Key } or nil
        if product.Id == 0 then
            priceText = string.format("Set ID • R$ %d", product.Price)
        end
        createEntry(product.Name, subtitle, priceText, purchaseData, false)
    end

    for _, boost in ipairs(Config.DeveloperProducts.Boosts) do
        local priceText = string.format("R$ %d", boost.Price)
        local subtitle = string.format("%d min %dx Converter", math.floor(boost.Duration / 60), boost.Multiplier)
        local purchaseData = boost.Id ~= 0 and { Type = "Product", Key = boost.Key } or nil
        if boost.Id == 0 then
            priceText = string.format("Set ID • R$ %d", boost.Price)
        end
        createEntry(boost.Name, subtitle, priceText, purchaseData, false)
    end

    local hasVip = currentState and currentState.Gamepasses and currentState.Gamepasses.VIP
    if hasVip then
        for _, item in ipairs(Config.VIPShop) do
            local priceText = string.format("%s Energy", formatNumber(item.Cost))
            local subtitle = string.format("%s", item.Description)
            createEntry(
                item.Name,
                subtitle,
                priceText,
                nil,
                false,
                function()
                    remotes.ActionRequest:FireServer("PurchaseVIPItem", { Key = item.Key })
                end,
                Color3.fromRGB(104, 209, 140)
            )
        end
    else
        local vipInfo = Config.Gamepasses.VIP
        local subtitle = "Unlock Crystal VIP to access exclusive boosts"
        local priceText
        local purchaseData
        if vipInfo then
            priceText = string.format("Unlock VIP • R$ %d", vipInfo.Price)
            if vipInfo.Id ~= 0 then
                purchaseData = { Type = "Gamepass", Key = "VIP" }
            end
        else
            priceText = "Unlock VIP"
        end

        createEntry("VIP Crystal Boutique", subtitle, priceText, purchaseData, false)
    end

    shopScroll.CanvasSize = UDim2.new(0, 0, 0, shopLayout.AbsoluteContentSize.Y)
end

local function updateUI()
    if not currentState then
        return
    end

    local serverNow = workspace:GetServerTimeNow()
    if currentState.ServerTime then
        serverTimeOffset = currentState.ServerTime - serverNow
    end

    local energyValue = currentState.Energy or 0
    local inventoryValue = currentState.Inventory or 0
    local multiplierValue = currentState.ConverterMultiplier or 1
    local zoneValue = currentState.ZoneLevel or 1
    local rebirthValue = currentState.Rebirths or 0

    energyLabel.Text = formatNumber(energyValue)
    local capacityValue = currentState.Capacity
    local capacityText = currentState.CapacityDisplay or tostring(capacityValue or 0)
    updateInventoryBarUI(inventoryValue, capacityValue, capacityText)
    multiplierLabel.Text = string.format("x%.2f Converter", multiplierValue)
    zoneLabel.Text = string.format("Zone %d / %d", zoneValue, #Config.Zones)
    if rebirthValue == 1 then
        rebirthLabel.Text = "1 Rebirth"
    else
        rebirthLabel.Text = string.format("%d Rebirths", rebirthValue)
    end

    if currentState.ActiveBoosts then
        local boostStrings = {}
        for key, data in pairs(currentState.ActiveBoosts) do
            local remaining = data.ExpiresIn and math.max(0, math.floor(data.ExpiresIn)) or nil
            local text = string.format("%s %dx", key, data.Multiplier or 1)
            if remaining then
                text ..= string.format(" (%ds)", remaining)
            end
            table.insert(boostStrings, text)
        end
        if #boostStrings > 0 then
            boostLabel.Text = "Boosts: " .. table.concat(boostStrings, ", ")
        else
            boostLabel.Text = "Boosts: None"
        end
    else
        boostLabel.Text = "Boosts: None"
    end

    if currentState.CapacityNextCost then
        setButtonState(buttons.Capacity, true, string.format("Upgrade Backpack\nCost: %s", formatNumber(currentState.CapacityNextCost)))
    else
        setButtonState(buttons.Capacity, false, "Backpack Maxed")
    end

    if currentState.SpeedNextCost then
        setButtonState(buttons.Speed, true, string.format("Upgrade Speed\nCost: %s", formatNumber(currentState.SpeedNextCost)))
    else
        setButtonState(buttons.Speed, false, "Speed Maxed")
    end

    if currentState.ConverterNextCost then
        setButtonState(buttons.Converter, true, string.format("Upgrade Converter\nCost: %s", formatNumber(currentState.ConverterNextCost)))
    else
        setButtonState(buttons.Converter, false, "Converter Maxed")
    end

    if currentState.NextZoneCost then
        setButtonState(buttons.UnlockZone, true, string.format("Unlock Next Zone\nCost: %s", formatNumber(currentState.NextZoneCost)))
    else
        setButtonState(buttons.UnlockZone, false, "All Zones Unlocked")
    end

    local maxZones = #Config.Zones
    if zoneValue >= maxZones then
        setButtonState(buttons.Rebirth, true, string.format("Rebirth\nCost: %s", formatNumber(currentState.RebirthCost or 0)))
    else
        setButtonState(buttons.Rebirth, false, "Unlock all zones first")
    end

    updateAbilityButtons()
    updateZoneTrackUI(zoneValue)
    updateMilestoneCardUI(currentState.TotalEnergy or energyValue)
    updateComboUI(currentState.Combo)
    updateEventUI()
    rebuildShop()
end

RunService.RenderStepped:Connect(function()
    if activeEvent then
        updateEventTimerDisplay()
    end

    if currentState and currentState.Combo then
        updateComboTimerDisplay(currentState.Combo)
    end
end)

local notificationTween
local function showNotification(text, color)
    notificationLabel.Text = text
    notificationFrame.BackgroundColor3 = color or Color3.fromRGB(47, 60, 102)
    notificationFrame.Visible = true
    notificationFrame.BackgroundTransparency = 0.2

    if notificationTween then
        notificationTween:Cancel()
    end

    notificationTween = TweenService:Create(notificationFrame, TweenInfo.new(0.5), { BackgroundTransparency = 0.2 })
    notificationTween:Play()

    task.delay(3, function()
        if notificationFrame.Visible then
            local fade = TweenService:Create(notificationFrame, TweenInfo.new(0.4), { BackgroundTransparency = 1 })
            fade.Completed:Connect(function()
                notificationFrame.Visible = false
                notificationFrame.BackgroundTransparency = 0.2
            end)
            fade:Play()
        end
    end)
end

local function showTutorial(text)
    tutorialLabel.Text = text
    tutorialFrame.Visible = true
    tutorialFrame.BackgroundTransparency = 0.05

    local fadeIn = TweenService:Create(tutorialFrame, TweenInfo.new(0.3), { BackgroundTransparency = 0.05 })
    fadeIn:Play()

    task.delay(6, function()
        local fadeOut = TweenService:Create(tutorialFrame, TweenInfo.new(0.4), { BackgroundTransparency = 1 })
        fadeOut.Completed:Connect(function()
            tutorialFrame.Visible = false
            tutorialFrame.BackgroundTransparency = 0.05
        end)
        fadeOut:Play()
    end)
end

remotes.StateUpdate.OnClientEvent:Connect(function(state)
    currentState = state
    updateUI()
end)

remotes.Notify.OnClientEvent:Connect(function(message)
    showNotification(message)
end)

remotes.Tutorial.OnClientEvent:Connect(function(message)
    showTutorial(message)
end)

sprintToggleButton.MouseButton1Click:Connect(function()
    local passes = currentState and currentState.Gamepasses or {}
    if not (passes and passes.HYPER_SPRINT) then
        remotes.PurchaseRequest:FireServer({ Type = "Gamepass", Key = "HYPER_SPRINT" })
        return
    end

    local settings = currentState and currentState.Settings or {}
    local enabled = settings and settings.HyperSprint == true
    remotes.ActionRequest:FireServer("ToggleHyperSprint", not enabled)
end)

autoToggleButton.MouseButton1Click:Connect(function()
    local passes = currentState and currentState.Gamepasses or {}
    if not (passes and passes.AUTO_COLLECTOR) then
        remotes.PurchaseRequest:FireServer({ Type = "Gamepass", Key = "AUTO_COLLECTOR" })
        return
    end

    local settings = currentState and currentState.Settings or {}
    local enabled = settings and settings.AutoCollector
    if enabled == nil then
        enabled = true
    end
    remotes.ActionRequest:FireServer("ToggleAutoCollector", not enabled)
end)

shopToggle.MouseButton1Click:Connect(function()
    shopFrame.Visible = not shopFrame.Visible
    shopToggle.Text = shopFrame.Visible and "Close Crystal Shop" or "Open Crystal Shop"
    if shopFrame.Visible then
        rebuildShop()
    end
end)

shopClose.MouseButton1Click:Connect(function()
    shopFrame.Visible = false
    shopToggle.Text = "Open Crystal Shop"
end)

-- Request an initial state if the server hasn't sent one yet
remotes.ActionRequest:FireServer("__REQUEST_STATE__")
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
</roblox>